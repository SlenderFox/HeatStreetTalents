import "playervars.ostw";
import "subroutines.ostw";

playervar Boolean pAbilityAvailable;
playervar Boolean pChainReactionImmune;
playervar Boolean pChainReactionOn;
playervar Number pAbilityCountdown;
playervar Number pAbilityActive;
playervar Vector pAbilityProjectile; // At one point randomly assigned to a bool
playervar Any pAbilityEnd;

void Cancel_Momentum() "Subroutine: Cancel player momentum"
{
	ApplyImpulse(
		EventPlayer(),
		-1 * DirectionFromAngles(HorizontalAngleFromDirection(VelocityOf(EventPlayer())), 0),
		0.001,
		Relative.ToWorld,
		ContraryMotion.CancelXYZ
	);
}

rule: "Ana: Multinade"
Event.OngoingPlayer
Team.Team1
Player.Ana
if (pTalent1)
if (IsUsingAbility2(EventPlayer()))
{
	for (gIterator = 0; 4; 1)
	{
		Wait(0.03, WaitBehavior.IgnoreCondition);
		SetAbilityCooldown(EventPlayer(), Button.Ability2, false);
		CancelPrimaryAction(EventPlayer());
		Wait(0.05, WaitBehavior.IgnoreCondition);
		PressButton(EventPlayer(), Button.Ability2);
	}
	Wait(2, WaitBehavior.IgnoreCondition);
}

rule: "Ana: Sleep Paralysis"
Event.OnDamageDealt
Team.Team1
Player.Ana
if (pTalent2)
if (EventAbility() == Button.Ability1)
{
	PlayEffect(AllPlayers(), PlayEffect.GoodExplosion, Color.Black, Victim(), 2);
	Wait(0.5, WaitBehavior.IgnoreCondition);
	WaitUntil(!HasStatus(Victim(), Status.Asleep), 5);
	PlayEffect(AllPlayers(), PlayEffect.ExplosionSound, Color.Black, EyePosition(Victim()), 150);
	PlayEffect(AllPlayers(), PlayEffect.GoodExplosion, Color.Black, Victim(), 6);
	PlayEffect(AllPlayers(), PlayEffect.RingExplosion, Color.Black, Victim(), 12);
	Damage(PlayersWithinRadius(Victim(), 6, Team.Team2, RadiusLOS.Surfaces), EventPlayer(), 150);
	SetStatus(PlayersWithinRadius(EyePosition(Victim()), 6, Team.Team2, RadiusLOS.Surfaces), null, Status.Hacked, 1.5);
}

rule: "Zenyatta: Stress Relief"
Event.OngoingPlayer
Team.Team1
Player.Zenyatta
if (pTalent1)
if (IsFiringSecondary(EventPlayer()))
{
	Wait(2, WaitBehavior.AbortWhenFalse);
	PlayEffect(EventPlayer(), PlayEffect.ExplosionSound, Color.Black, EventPlayer(), 150);
	pDamageDealt += 50;
	Wait(0.75, WaitBehavior.IgnoreCondition);
	pDamageDealt -= 50;
}

rule: "Zenyatta: Perfect Balance"
Event.OngoingPlayer
Team.Team1
Player.Zenyatta
if (pTalent2)
if (IsUsingUltimate(EventPlayer()))
{
	while (IsUsingUltimate(EventPlayer()))
	{
		StartDamageOverTime(
			PlayersWithinRadius(EventPlayer(), 12, Team.Team2, RadiusLOS.Surfaces),
			EventPlayer(),
			1,
			100
		);
		PlayEffect(
			AllPlayers(),
			PlayEffect.RingExplosion,
			Color.Orange,
			EventPlayer(),
			24
		);
		Wait(1, WaitBehavior.IgnoreCondition);
	}
}

rule: "Orisa: Shrapnel"
Event.OngoingPlayer
Team.Team1
Player.Orisa
if (pTalent1)
if (IsUsingAbility2(EventPlayer()))
{
	while (IsUsingAbility2(EventPlayer()))
	{
		CreateProjectile(
			ProjectileType.OrisaFusionDriver,
			EventPlayer(),
			EventPlayer().EyePosition()
				+ Normalize(CrossProduct(
					EventPlayer().FacingDirection(),
					Up()
				)) * RandomReal(-1.1, 1.1)
				+ Normalize(CrossProduct(
					CrossProduct(
						EventPlayer().FacingDirection(),
						Up()
					),
					EventPlayer().FacingDirection()
				)) * RandomReal(-1.1, 1.1),
			Direction: EventPlayer().FacingDirection()
				+ Normalize(CrossProduct(
					EventPlayer().FacingDirection(),
					Up()
				)) * RandomReal(-0.1, 0.1)
				+ Normalize(CrossProduct(
					CrossProduct(
						EventPlayer().FacingDirection(),
						Up()
					),
					EventPlayer().FacingDirection()
				)) * RandomReal(-0.1, 0.1),
			Relative.ToWorld,
			ModifyHealthType.Damage,
			Team.Team2,
			5,
			false,
			false,
			PlayEffect.GoodExplosion,
			PlayEffect.ExplosionSound,
			0,
			60,
			0.5,
			4,
			false,
			false
		);
		Wait(0.01, WaitBehavior.IgnoreCondition);
	}
}

rule: "Orisa: knockback fix"
Event.PlayerDealtKnockback
Team.Team1
Player.Orisa
if (EventAbility() != Button.Ability1)
if (EventAbility() != Button.Melee)
{
	SetStatus(Victim(), EventPlayer(), Status.Rooted, 0.1);
}

rule: "Orisa: tailwind"
Event.PlayerDealtKnockback
Team.Team1
Player.Orisa
if (pTalent2)
if (EventAbility() == Button.SecondaryFire)
{
	Damage(PlayersWithinRadius(Victim(), 6, Team.Team2, RadiusLOS.Surfaces), EventPlayer(), 50);
	ApplyImpulse(
		PlayersWithinRadius(Victim(), 6, Team.Team2, RadiusLOS.Surfaces).Remove(Victim()),
		DirectionTowards(Victim(), EventPlayer()),
		-15,
		Relative.ToWorld,
		ContraryMotion.Cancel
	);
	ApplyImpulse(
		PlayersWithinRadius(Victim(), 6, Team.Team2, RadiusLOS.Surfaces).Remove(Victim()),
		Up(),
		2,
		Relative.ToWorld,
		ContraryMotion.Cancel
	);
	SetStatus(PlayersWithinRadius(Victim(), 6, Team.Team2, RadiusLOS.Surfaces), null, Status.Stunned, 1.2);
}

rule: "Sigma: Accretion Disk"
Event.OngoingPlayer
Team.Team1
Player.Sigma
if (pTalent1)
if (IsUsingAbility2(EventPlayer()))
{
	SetProjectileSpeed(EventPlayer(), 150);
	SetProjectileGravity(EventPlayer(), 0);
	WaitUntil(!pTalent1 || !IsUsingAbility2(EventPlayer()), 5);
	SetProjectileSpeed(EventPlayer(), 100);
	SetProjectileGravity(EventPlayer(), 100);
}

rule: "Sigma: Accretion Disk"
Event.PlayerDealtKnockback
Team.Team1
Player.Sigma
if (pTalent1)
if (EventAbility() == Button.Ability2)
if (Victim() != EventPlayer())
{
	SetStatus(Victim(), EventPlayer(), Status.KnockedDown, 1.5);
	Damage(Victim(), EventPlayer(), EventDamage() * 0.75);
}

rule: "Sigma: String Theory"
Event.OngoingPlayer
Team.Team1
Player.Sigma
if (pTalent2)
if (IsUsingAbility1(EventPlayer()))
{
	pAbilityCountdown = EventPlayer().Health()
		- HealthOfType(EventPlayer(), HealthType.Health)
		- HealthOfType(EventPlayer(), HealthType.Armor)
		- HealthOfType(EventPlayer(), HealthType.Shields);
	Wait(1.8, WaitBehavior.IgnoreCondition);
	pAbilityEnd = (10 + EventPlayer().Health()
		- HealthOfType(EventPlayer(), HealthType.Health)
		- HealthOfType(EventPlayer(), HealthType.Armor)
		- HealthOfType(EventPlayer(), HealthType.Shields)
		- pAbilityCountdown) * 3;
	CreateProjectile(
		ProjectileType.SigmaHypersphere,
		EventPlayer(),
		EventPlayer().EyePosition(),
		EventPlayer().FacingDirection(),
		Relative.ToWorld,
		ModifyHealthType.Damage,
		Team.Team2,
		pAbilityEnd,
		pAbilityEnd * 0.5,
		10,
		PlayEffect.SigmaHypersphereImplosionEffect,
		PlayEffect.AsheDynamiteExplosionSound,
		0,
		50,
		10,
		pAbilityEnd * 0.25,
		false,
		false
	);
}

rule: "Ashe: Black Gunpowder"
Event.PlayerDealtKnockback
Team.Team1
Player.Ashe
if (pTalent1)
if (EventAbility() == Button.Ability1)
if (Victim() != EventPlayer())
{
	StartDamageOverTime(Victim(), EventPlayer(), 3, EventDamage() * 2.5);
	SetStatus(Victim(), EventPlayer(), Status.Burning, 3);
}

rule: "Ashe: Dancing Flames"
Event.OnElimination
Team.Team1
Player.Ashe
if (pTalent2)
{
	PlayEffect(AllPlayers(), PlayEffect.ExplosionSound, Color.Orange, EyePosition(Victim()), 120);
	PlayEffect(AllPlayers(), PlayEffect.GoodExplosion, Color.Orange, Victim(), 5);
	PlayEffect(AllPlayers(), PlayEffect.BadPickupEffect, Color.Yellow, Victim(), 5);
	StartDamageOverTime(PlayersWithinRadius(Victim(), 5, Team.Team2, RadiusLOS.Surfaces), EventPlayer(), 3, 15);
	SetStatus(PlayersWithinRadius(Victim(), 5, Team.Team2, RadiusLOS.Surfaces), EventPlayer(), Status.Burning, 3);
	Damage(PlayersWithinRadius(Victim(), 5, Team.Team2, RadiusLOS.Surfaces), EventPlayer(), 30);
}

rule: "Widowmaker: Baiser De Soie"
Event.OnDamageDealt
Team.Team1
Player.Widowmaker
if (pTalent1)
if (EventAbility() == Button.PrimaryFire)
if (IsFiringSecondary(EventPlayer()))
if (EventWasCriticalHit())
if (NormalizedHealth(Victim()) <= 0.3)
if (!Victim().pIsLivingBoss)
if (!Victim().pIvIsPortal)
{
	PlayEffect(AllPlayers(), PlayEffect.BadPickupEffect, Color.Violet, Victim(), 3);
	Damage(Victim(), EventPlayer(), 10000);
	Damage(PlayersWithinRadius(Victim(), 3, Team.Team2, RadiusLOS.Surfaces), EventPlayer(), EventDamage());
}

rule: "Widowmaker: Parting Gift"
Event.OngoingPlayer
Team.Team1
Player.Widowmaker
if (pTalent2)
if (IsUsingAbility1(EventPlayer()))
if (SpeedOf(EventPlayer()) >= 20)
{
	while (IsUsingAbility1(EventPlayer()))
	{
		CreateProjectile(ProjectileType.RamattraRavenousVortexSphere, EventPlayer(), null, Up(), Relative.ToWorld, ModifyHealthType.Damage, Team.Team2, 50, 2, 4, PlayEffect.RingExplosion, PlayEffect.ExplosionSound, 0.05, 15, 3, 8, 1, 100);
		Wait(0.15, WaitBehavior.IgnoreCondition);
	}
	for (gIterator = 0; 4; 1)
	{
		Wait(0.15, WaitBehavior.IgnoreCondition);
		CreateProjectile(ProjectileType.RamattraRavenousVortexSphere, EventPlayer(), null, Up(), Relative.ToWorld, ModifyHealthType.Damage, Team.Team2, 50, 2, 4, PlayEffect.RingExplosion, PlayEffect.ExplosionSound, 0.05, 15, 3, 8, 1, 100);
	}
}

rule: "Torbjorn: Heatwave"
Event.OngoingPlayer
Team.Team1
Player.Torbjorn
if (pTalent1)
if (IsUsingAbility2(EventPlayer()) || IsUsingUltimate(EventPlayer()))
{
	PlayEffect(AllPlayers(), PlayEffect.RingExplosion, Color.Orange, EventPlayer().Position(), 11);
	PlayEffect(AllPlayers(), PlayEffect.RingExplosion, Color.Orange, EventPlayer().Position(), 12);
	StartDamageOverTime(
		PlayersWithinRadius(EventPlayer(), 6, Team.Team2, RadiusLOS.Surfaces),
		EventPlayer(),
		3,
		20
	);
	SetStatus(
		PlayersWithinRadius(EventPlayer(), 6, Team.Team2, RadiusLOS.Surfaces),
		EventPlayer(),
		Status.Burning,
		3
	);
	Damage(PlayersWithinRadius(EventPlayer(), 6, Team.Team2, RadiusLOS.Surfaces), EventPlayer(), 15);
	Wait(0.75, WaitBehavior.IgnoreCondition);
	LoopIfConditionIsTrue();
}

rule: "[Torbjorn] Foundry"
Event.OnDamageDealt
Team.Team1
Player.Torbjorn
if (pTalent2)
if (EventAbility() == Button.PrimaryFire)
if (Weapon(EventPlayer()) == 2)
if (DistanceBetween(EventPlayer(), Victim()) < 2.5)
{
	Damage(Victim(), EventPlayer(), EventDamage() * 0.4);
	PlayEffect(AllPlayers(), PlayEffect.BadExplosion, Color.Orange, Victim(), 0.25);
}

rule: "[Torbjorn] Foundry - Bonus Speed"
Event.OngoingPlayer
Team.Team1
Player.Torbjorn
if (pTalent2)
if (Weapon(EventPlayer()) == 2)
{
	pMoveSpeed += 40;
	WaitUntil(Weapon(EventPlayer()) != 2 || EventPlayer().IsDead() || !pTalent2, 99999);
	pMoveSpeed -= 40;
}

rule: "Reinhardt: Fire Blast"
Event.OnDamageDealt
Team.Team1
Player.Reinhardt
if (pTalent1)
if (EventAbility() == Button.Ability2)
{
	PlayEffect(AllPlayers(), PlayEffect.GoodExplosion, Color.Orange, Victim(), 5);
	StartDamageOverTime(
		PlayersWithinRadius(Victim(), 5, Team.Team2, RadiusLOS.Surfaces),
		EventPlayer(),
		5,
		20
	);
	SetStatus(
		PlayersWithinRadius(Victim(), 5, Team.Team2, RadiusLOS.Surfaces),
		EventPlayer(),
		Status.Burning,
		5
	);
}

rule: "Reinhardt: Epicenter"
Event.OngoingPlayer
Team.Team1
Player.Reinhardt
if (pTalent2)
if (IsUsingUltimate(EventPlayer()))
if (IsOnGround(EventPlayer()))
{
	SetStatus(
		PlayersWithinRadius(EventPlayer(), 20, Team.Team2, RadiusLOS.Surfaces),
		EventPlayer(),
		Status.KnockedDown,
		2.5
	);
	for (gIterator = 0; 3; 1)
	{
		Wait(0.032, WaitBehavior.IgnoreCondition);
		Damage(
			PlayersWithinRadius(EventPlayer(), gIterator * 10, Team.Team2, RadiusLOS.Surfaces),
			EventPlayer(),
			50
		);
		PlayEffect(
			AllPlayers(),
			PlayEffect.RingExplosion,
			Color.Orange,
			EventPlayer().Position(),
			gIterator * 20
		);
	}
	Wait(5, WaitBehavior.IgnoreCondition);
}

rule: "Brigitte: Endeavor"
Event.OngoingPlayer
Team.Team1
Player.Brigitte
if (pTalent1)
if (pAbilityAvailable)
{
	pEffects[1] = CreateEffect(
		AllPlayers(),
		Effect.EchoCloningEffect,
		Team.Team1,
		EventPlayer(),
		0.4,
		EffectRev.VisibleToPositionAndRadius
	);
	PlayEffect(
		AllPlayers(),
		PlayEffect.RingExplosion,
		Color.Orange,
		EventPlayer().EyePosition(),
		15
	);
	Heal(PlayersWithinRadius(EventPlayer(), 15, Team.Team1, RadiusLOS.Off), EventPlayer(), 200);
	pDamageDealt += 150;
	pMoveSpeed += 75;
	pHpPool[1] = AddHealthPoolToPlayer(
		EventPlayer(),
		HealthType.Armor,
		MaxHealth(EventPlayer()) / 3,
		false,
		true
	);
	Wait(1, WaitBehavior.IgnoreCondition);
	WaitUntil(!pTalent1 || EventPlayer().IsDead() || pAbilityAvailable, 6);
	pDamageDealt -= 150;
	pMoveSpeed -= 75;
	RemoveHealthPoolFromPlayer(pHpPool[1]);
	DestroyEffect(pEffects[1]);
	Wait(0.1, WaitBehavior.IgnoreCondition);
	LoopIfConditionIsTrue();
}

rule: "Brigitte: Endeavor"
Event.OngoingPlayer
Team.Team1
Player.Brigitte
if (pTalent1)
if (AbilityCooldown(EventPlayer(), Button.SecondaryFire) >= 0.1)
{
	pAbilityAvailable = true;
	Wait(0.25, WaitBehavior.IgnoreCondition);
	pAbilityAvailable = false;
}

rule: "Brigitte: Whiplash"
Event.PlayerDealtKnockback
Team.Team1
Player.Brigitte
if (pTalent2)
if (IsUsingAbility1(EventPlayer()))
{
	PlayEffect(AllPlayers(), PlayEffect.RingExplosionSound, Color.Green, Victim(), 100);
	PlayEffect(AllPlayers(), PlayEffect.BadExplosion, Color.Orange, Victim(), 2.5);
	PlayEffect(AllPlayers(), PlayEffect.BadPickupEffect, Color.Orange, Victim(), 2.5);
	Damage(PlayersWithinRadius(Victim(), 2.5, Team.Team2, RadiusLOS.Surfaces), EventPlayer(), 100);
	SetStatus(PlayersWithinRadius(Victim(), 2.5, Team.Team2, RadiusLOS.Surfaces), EventPlayer(), Status.Stunned, 1.5);
}

rule: "Genji: Venomous Strike"
Event.OnDamageDealt
Team.Team1
Player.Genji
if (pTalent1)
if (EventAbility() == Button.Ability1)
{
	StartHealOverTime(EventPlayer(), EventPlayer(), 3, 15);
	StartDamageOverTime(Victim(), EventPlayer(), 3, 15);
	Heal(EventPlayer(), EventPlayer(), 5);
	Wait(0.25, WaitBehavior.RestartWhenTrue);
	Wait(2, WaitBehavior.IgnoreCondition);
}

void create_shuriken(in Vector angle)
{
	CreateProjectile(
		ProjectileType.GenjiShuriken,
		EventPlayer(),
		null,
		angle,
		Relative.ToWorld,
		ModifyHealthType.Damage,
		Team.Team2,
		27,
		2,
		false,
		PlayEffect.GoodExplosion,
		PlayEffect.ExplosionSound,
		false,
		60,
		4,
		false,
		false,
		false
	);
}

rule: "Genji: Sharpened Storm - Primary"
Event.OngoingPlayer
Team.Team1
Player.Genji
if (pTalent2)
if (IsFiringPrimary(EventPlayer()))
if (!IsUsingUltimate(EventPlayer()))
{
	Wait(0.25, WaitBehavior.IgnoreCondition);
	create_shuriken(null);
	Wait(0.1, WaitBehavior.IgnoreCondition);
	create_shuriken(null);
	Wait(0.1, WaitBehavior.IgnoreCondition);
	create_shuriken(null);
}

rule: "Genji: Sharpened Storm - Secondary"
Event.OngoingPlayer
Team.Team1
Player.Genji
if (pTalent2)
if (IsFiringSecondary(EventPlayer()))
{
	MinWait();
	create_shuriken(DirectionFromAngles(
		HorizontalFacingAngleOf(EventPlayer()) + 4.5,
		VerticalFacingAngleOf(EventPlayer())
	));
	create_shuriken(DirectionFromAngles(
		HorizontalFacingAngleOf(EventPlayer()) - 4.5,
		VerticalFacingAngleOf(EventPlayer())
	));
	create_shuriken(null);
}

rule: "Mercy: Wings of Grand"
Event.OngoingPlayer
Team.Team1
Player.Mercy
if (pTalent1)
if (IsAlive(EventPlayer()))
if (IsUsingAbility1(EventPlayer()))
{
	if (SpeedOf(EventPlayer()) > 10)
	{
		Damage(
			PlayersWithinRadius(
				EventPlayer(), 4, Team.Team2, RadiusLOS.Surfaces).Filter(p => !HasStatus(p, Status.KnockedDown)
			),
			EventPlayer(),
			35
		);
		SetStatus(
			PlayersWithinRadius(EventPlayer(), 4, Team.Team2, RadiusLOS.Surfaces),
			EventPlayer(),
			Status.KnockedDown,
			0.8
		);
		ApplyImpulse(
			PlayersWithinRadius(EventPlayer(), 4, Team.Team2, RadiusLOS.Surfaces),
			Normalize(VelocityOf(EventPlayer()))
				+ DirectionTowards(EventPlayer(), ThrottleOf(EventPlayer()))
				+ Up() * 1.1,
			7.5,
			Relative.ToWorld,
			ContraryMotion.Cancel
		);
		PlayEffect(AllPlayers(), PlayEffect.BadExplosion, Color.Yellow, EventPlayer().Position(), 0.15);
	}
	Wait(0.25, WaitBehavior.IgnoreCondition);
	LoopIfConditionIsTrue();
}

rule: "Mercy: Holy Light Missiles"
Event.OngoingPlayer
Team.Team1
Player.Mercy
if (pTalent2)
if (IsUsingUltimate(EventPlayer()))
{
	CreateEffect(AllPlayers(), Effect.Orb, Color.Yellow, pAbilityProjectile, 1, EffectRev.VisibleToPositionAndRadius);
	pEffects[1] = LastCreatedEntity();
	pAbilityProjectile = EventPlayer().EyePosition();
	ChaseVariableAtRate(pAbilityProjectile, pAbilityEnd, 100, RateChaseReevaluation.DestinationAndRate);
	pAbilityEnd = RayCastHitPosition(EventPlayer().EyePosition(), EventPlayer().EyePosition() + EventPlayer().FacingDirection() * 60, AllLivingPlayers(Team.Team2), AllPlayers(Team.Team1), true);
	WaitUntil(!pTalent2 || pAbilityEnd == pAbilityProjectile, 1);
	DestroyEffect(pEffects[1]);
	StopChasingVariable(pAbilityCountdown);
	PlayEffect(AllPlayers(), PlayEffect.RingExplosionSound, Color.Green, pAbilityProjectile, 100);
	PlayEffect(AllPlayers(), PlayEffect.BadExplosion, Color.Yellow, pAbilityProjectile, 6);
	PlayEffect(AllPlayers(), PlayEffect.GoodPickupEffect, Color.White, pAbilityProjectile, 6);
	Damage(PlayersWithinRadius(pAbilityProjectile, 6, Team.Team2, RadiusLOS.Surfaces), EventPlayer(), 150);
	Heal(PlayersWithinRadius(pAbilityProjectile, 6, Team.Team1, RadiusLOS.Surfaces), EventPlayer(), 150);
	Wait(1.5, WaitBehavior.IgnoreCondition);
	LoopIfConditionIsTrue();
}

rule: "Tracer: Vortex"
Event.OngoingPlayer
Team.Team1
Player.Tracer
if (pTalent1)
if (IsUsingAbility2(EventPlayer()))
{
	Heal(PlayersWithinRadius(EventPlayer(), 10, Team.Team2, RadiusLOS.Surfaces), EventPlayer(), 1);
	Damage(PlayersWithinRadius(EventPlayer(), 10, Team.Team2, RadiusLOS.Surfaces), EventPlayer(), 25);
	PlayEffect(AllPlayers(), PlayEffect.RingExplosion, Color.Red, EventPlayer().Position(), 20);
	PlayEffect(AllPlayers(), PlayEffect.RingExplosion, Color.Yellow, EventPlayer().Position(), 18);
	PlayEffect(AllPlayers(), PlayEffect.RingExplosion, Color.Green, EventPlayer().Position(), 16);
	PlayEffect(AllPlayers(), PlayEffect.RingExplosion, Color.Aqua, EventPlayer().Position(), 14);
	SetEnvironmentCreditPlayer(PlayersWithinRadius(EventPlayer(), 10, Team.Team2, RadiusLOS.Surfaces), EventPlayer());
}

rule: "Tracer: Vortex 2"
Event.OnHealingTaken
Team.Team2
{
	AbortIf(!Healer().pTalent1);
	AbortIf(pIsLivingBoss);
	AbortIf(!IsUsingAbility2(Healer()));
	DisableMovementCollisionWithPlayers(EventPlayer());
	ApplyImpulse(EventPlayer(), Up(), 3, Relative.ToWorld, ContraryMotion.Cancel);
	SetGravity(EventPlayer(), false);
	Wait(0.05, WaitBehavior.IgnoreCondition);
	ApplyImpulse(EventPlayer(), DirectionTowards(EventPlayer(), Healer()), DistanceBetween(EventPlayer(), Healer()) * 3.4, Relative.ToWorld, ContraryMotion.Cancel);
	SetStatus(EventPlayer(), null, Status.Rooted, 1);
	Wait(0.23, WaitBehavior.IgnoreCondition);
	SetGravity(EventPlayer(), 100);
	EnableMovementCollisionWithPlayers(EventPlayer());
	Cancel_Momentum();
}

rule: "Tracer: Chain Reaction Initial"
Event.OnDamageDealt
Team.Team1
Player.Tracer
if (pTalent2)
if (EventAbility() == Button.Ultimate)
# Ignore stick damage
if (EventDamage() > 20)
{
	Victim().pChainReactionOn = true;
}

rule: "Tracer: Chain Reaction Propagation"
Event.OngoingPlayer
Team.Team2
if (IsTrueForAny(FilteredArray(AllLivingPlayers(Team.Team2), ArrayElement().pChainReactionOn), DistanceBetween(EventPlayer(), ArrayElement()) <= 7))
if (!pChainReactionImmune)
if (!pChainReactionOn)
if (IsAlive(EventPlayer()))
{
	Wait(0.25, WaitBehavior.IgnoreCondition);
	pChainReactionOn = true;
}

rule: "Tracer: Chain Reaction Damage"
Event.OngoingPlayer
Team.Team2
if (pChainReactionOn)
{
	Wait(0.1, WaitBehavior.IgnoreCondition);
	PlayEffect(AllPlayers(), PlayEffect.GoodExplosion, Color.Aqua, EventPlayer(), 3);
	//Damage(EventPlayer(), PlayersOnHero(Hero.Tracer, Team.Team1), 200);
	# Picks the tracer with the lowest ult charge
	Damage(EventPlayer(), PlayersOnHero(Hero.Tracer, Team.Team1).Sort(p => UltimateChargePercent(p))[0], 200);
	Wait(0.5, WaitBehavior.IgnoreCondition);
	pChainReactionImmune = true;
	pChainReactionOn = false;
	Wait(2, WaitBehavior.IgnoreCondition);
	pChainReactionImmune = false;
}

rule: "Symmetra: Sentry Paragon"
Event.OngoingPlayer
Team.Team1
Player.Symmetra
if (pTalent1)
if (IsAlive(EventPlayer()))
{
	Wait(0.5, WaitBehavior.AbortWhenFalse);
	StartDamageModification(AllPlayers(Team.Team2), EventPlayer(), 66.667, DamageModificationRev.ReceiversDamagersAndDamagePercent);
	pDamageMod[1] = LastDamageModificationID();
	pDamageDealt += 50;
	WaitUntil(!pTalent1 || EventPlayer().IsDead(), 99999);
	pDamageDealt -= 50;
	StopDamageModification(pDamageMod[1]);
	Wait(0.1, WaitBehavior.IgnoreCondition);
	LoopIfConditionIsTrue();
}

rule: "Symmetra: Shield Generator"
Event.OnFinalBlow
Team.Team1
Player.Symmetra
if (pTalent2)
{
	pDamageDealt += 30;
	pMoveSpeed += 30;
	AddHealthPoolToPlayer(AllPlayers(Team.Team1), HealthType.Shields, Min(200, MaxHealth(EventPlayer()) * 0.25), false, false);
	pHpPool[6] = LastCreatedHealthPool();
	CreateEffect(AllPlayers(), Effect.AnaNanoBoostedEffect, Color.Team1, EventPlayer(), 1, EffectRev.VisibleToPositionAndRadius);
	pEffects[1] = LastCreatedEntity();
	WaitUntil(!pTalent2 || EventPlayer().IsDead(), 10);
	DestroyEffect(pEffects[1]);
	RemoveHealthPoolFromPlayer(pHpPool[6]);
	pDamageDealt -= 30;
	pMoveSpeed -= 30;
}

rule: "[Hanzo] Arrow Rain"
Event.OngoingPlayer
Team.Team1
Player.Hanzo
if (pTalent1)
if (IsFiringPrimary(EventPlayer()))
if (IsUsingAbility2(EventPlayer()))
{
	for (gIterator = 0; 2; 1)
	{
		CreateProjectile(ProjectileType.MeiIcicle, EventPlayer(), EventPlayer().EyePosition() + Down() * 0.5, DirectionFromAngles(HorizontalFacingAngleOf(EventPlayer()) + RandomReal(-2, 2), VerticalFacingAngleOf(EventPlayer()) + RandomReal(-2, 2)), Relative.ToWorld, ModifyHealthType.Damage, Team.Team2, 70, 2, 0, PlayEffect.BadExplosion, PlayEffect.ExplosionSound, 0, 110, 5, 0, 1, 5);
		CreateProjectile(ProjectileType.MeiIcicle, EventPlayer(), EventPlayer().EyePosition() + Down() * 0.5, DirectionFromAngles(HorizontalFacingAngleOf(EventPlayer()) + RandomReal(-2, 2), VerticalFacingAngleOf(EventPlayer()) + RandomReal(-2, 2)), Relative.ToWorld, ModifyHealthType.Damage, Team.Team2, 70, 2, 0, PlayEffect.BadExplosion, PlayEffect.ExplosionSound, 0, 110, 5, 0, 1, 5);
	}
}

rule: "Hanzo: Stormbreak"
Event.OnFinalBlow
Team.Team1
Player.Hanzo
if (pTalent2)
{
	pAbilityCountdown = 4;
	ChaseVariableAtRate(pAbilityCountdown, 0, 1, RateChaseReevaluation.DestinationAndRate);
}

rule: "Hanzo: Stormbreak - Boost"
Event.OngoingPlayer
Team.Team1
Player.Hanzo
if (pTalent2)
if (pAbilityCountdown > 0)
{
	CreateEffect(AllPlayers(), Effect.WinstonPrimalRageEffect, Color.Team1, EventPlayer(), 1, EffectRev.VisibleToPositionAndRadius);
	pEffects[1] = LastCreatedEntity();
	WaitUntil(EventPlayer().IsDead() || !pAbilityCountdown || !pTalent2, 99999);
	pAbilityCountdown = false;
	DestroyEffect(pEffects[1]);
	StopChasingVariable(pAbilityCountdown);
}

rule: "Hanzo: Stormbreak - Reset Cooldowns For Storm Arrows"
Event.OngoingPlayer
Team.Team1
Player.Hanzo
if (pAbilityCountdown > 0)
if (AbilityCooldown(EventPlayer(), Button.Ability2) > 0)
{
	SetAbilityCooldown(EventPlayer(), Button.Ability2, false);
}

rule: "Echo: Bomber Jacket"
Event.OngoingPlayer
Team.Team1
Player.Echo
if (pTalent1)
if (IsUsingAbility1(EventPlayer()))
{
	CreateHomingProjectile(ProjectileType.EchoStickyBomb, EventPlayer(), EventPlayer().EyePosition() + WorldVectorOf(Vector(-0.5, false, false), EventPlayer(), LocalVector.Rotation), Down(), Relative.ToWorld, ModifyHealthType.Damage, Team.Team2, 30, 1, 1.5, PlayEffect.RingExplosion, PlayEffect.ExplosionSound, 0, 20, 5, 0, SortedArray(FilteredArray(AllPlayers(Team.Team2), IsInLineOfSight(EventPlayer(), ArrayElement(), BarrierLOS.NoBarriersBlock) && ArrayElement().pIsAlive), DistanceBetween(EventPlayer(), ArrayElement()))[0], 1);
	CreateHomingProjectile(ProjectileType.EchoStickyBomb, EventPlayer(), EventPlayer().EyePosition() + WorldVectorOf(Vector(0.5, false, false), EventPlayer(), LocalVector.Rotation), Down(), Relative.ToWorld, ModifyHealthType.Damage, Team.Team2, 30, 1, 1.5, PlayEffect.RingExplosion, PlayEffect.ExplosionSound, 0, 20, 5, 0, SortedArray(FilteredArray(AllPlayers(Team.Team2), IsInLineOfSight(EventPlayer(), ArrayElement(), BarrierLOS.NoBarriersBlock) && ArrayElement().pIsAlive), DistanceBetween(EventPlayer(), ArrayElement()))[0], 1);
	Wait(0.25, WaitBehavior.IgnoreCondition);
	LoopIfConditionIsTrue();
}

rule: "Echo: Focusing Optics"
Event.OnDamageDealt
Team.Team1
Player.Echo
if (pTalent2)
if (EventAbility() == Button.Ability2)
if (!IsDuplicating(EventPlayer()))
if (NormalizedHealth(Victim()) > 0.5)
if (NormalizedHealth(Victim()) <= 0.9)
{
	Damage(Victim(), EventPlayer(), EventDamage() * 3);
	PlayEffect(AllPlayers(), PlayEffect.BadExplosion, Color.Violet, Victim(), 0.5);
}

rule: "[Lucio] Chord Cadence"
Event.OngoingPlayer
Team.Team1
Player.Lucio
if (pTalent1)
if (IsUsingAbility2(EventPlayer()))
{
	WaitUntil(!IsUsingAbility2(EventPlayer()), 4);
	SetAbilityCooldown(EventPlayer(), Button.Ability2, 0);
	AbortIf(EventPlayer().IsDead());
	CancelPrimaryAction(EventPlayer());
	PressButton(EventPlayer(), Button.Ability2);
	Wait(4, WaitBehavior.IgnoreCondition);
}

rule: "[Lucio] Chord Cadence burstfire"
Event.OngoingPlayer
Team.Team1
Player.Lucio
if (pTalent1)
if (IsUsingAbility2(EventPlayer()))
if (IsFiringPrimary(EventPlayer()))
{
	for (gIterator = 0; 4; 1)
	{
		CreateProjectile(ProjectileType.LucioSonicAmplifier, EventPlayer(), EventPlayer().EyePosition() + Down() * 0.5, DirectionFromAngles(HorizontalFacingAngleOf(EventPlayer()) + RandomReal(-1, 1), VerticalFacingAngleOf(EventPlayer()) + RandomReal(-1, 1)), Relative.ToWorld, ModifyHealthType.Damage, OppositeTeamOf(TeamOf(EventPlayer())), 20, 2, 0, PlayEffect.BadExplosion, PlayEffect.ExplosionSound, 0, 50, 5, 0, 0, 0);
		CreateProjectile(ProjectileType.LucioSonicAmplifier, EventPlayer(), EventPlayer().EyePosition() + Down() * 0.5, DirectionFromAngles(HorizontalFacingAngleOf(EventPlayer()) + RandomReal(-1, 1), VerticalFacingAngleOf(EventPlayer()) + RandomReal(-1, 1)), Relative.ToWorld, ModifyHealthType.Damage, OppositeTeamOf(TeamOf(EventPlayer())), 20, 2, 0, PlayEffect.BadExplosion, PlayEffect.ExplosionSound, 0, 50, 5, 0, 0, 0);
		if (!IsFiringPrimary(EventPlayer()))
		{
			break;
		}
		Wait(0.04, WaitBehavior.IgnoreCondition);
	}
	Wait(0.05, WaitBehavior.IgnoreCondition);
	LoopIfConditionIsTrue();
}

rule: "Lucio: Reverse Amp"
Event.OngoingPlayer
Team.Team1
Player.Lucio
if (IsUsingAbility2(EventPlayer()))
if (pTalent2)
{
	if (IsUsingAbility1(EventPlayer()))
	{
		SetStatus(PlayersWithinRadius(EventPlayer(), 12, Team.Team2, RadiusLOS.Surfaces), EventPlayer(), Status.Rooted, 0.75);
	}
	else
	{
		Damage(PlayersWithinRadius(EventPlayer(), 12, Team.Team2, RadiusLOS.Surfaces), EventPlayer(), 30);
		Wait(0.5, WaitBehavior.IgnoreCondition);
		LoopIfConditionIsTrue();
	}
}

rule: "D.Va: Voltage Grid"
Event.OngoingPlayer
Team.Team1
Player.Dva
if (IsFiringSecondary(EventPlayer()))
if (pTalent1)
{
	PlayEffect(AllPlayers(), PlayEffect.BadExplosion, Color.Turquoise, EventPlayer().EyePosition() + EventPlayer().FacingDirection() * 2, 0.15);
	PlayEffect(AllPlayers(), PlayEffect.BadExplosion, Color.Turquoise, EventPlayer().EyePosition() + EventPlayer().FacingDirection() * 5, 0.15);
	PlayEffect(AllPlayers(), PlayEffect.BadExplosion, Color.Turquoise, EventPlayer().EyePosition() + EventPlayer().FacingDirection() * 8, 0.15);
	Wait(0.3, WaitBehavior.IgnoreCondition);
	Damage(PlayersWithinRadius(EventPlayer().EyePosition() + EventPlayer().FacingDirection() * 2, 2.5, Team.Team2, RadiusLOS.Off), EventPlayer(), 20);
	Damage(PlayersWithinRadius(EventPlayer().EyePosition() + EventPlayer().FacingDirection() * 5, 2.5, Team.Team2, RadiusLOS.Off), EventPlayer(), 20);
	Damage(PlayersWithinRadius(EventPlayer().EyePosition() + EventPlayer().FacingDirection() * 8, 2.5, Team.Team2, RadiusLOS.Off), EventPlayer(), 20);
	SetStatus(PlayersWithinRadius(EventPlayer().EyePosition() + EventPlayer().FacingDirection() * 2, 2.5, Team.Team2, RadiusLOS.Off), EventPlayer(), Status.Rooted, 0.4);
	SetStatus(PlayersWithinRadius(EventPlayer().EyePosition() + EventPlayer().FacingDirection() * 5, 2.5, Team.Team2, RadiusLOS.Off), EventPlayer(), Status.Rooted, 0.4);
	SetStatus(PlayersWithinRadius(EventPlayer().EyePosition() + EventPlayer().FacingDirection() * 8, 2.5, Team.Team2, RadiusLOS.Off), EventPlayer(), Status.Rooted, 0.4);
	LoopIfConditionIsTrue();
}

rule: "D.Va: Shooting Star"
Event.PlayerDealtKnockback
Team.Team1
Player.Dva
if (EventAbility() == Button.Ability1)
if (pTalent2)
{
	Damage(Victim(), EventPlayer(), 30);
	SetStatus(Victim(), null, Status.Burning, 3);
	StartDamageOverTime(Victim(), EventPlayer(), 3, 35);
	PlayEffect(AllPlayers(), PlayEffect.BadExplosion, Color.Red, Victim(), 1);
}

rule: "Zarya- Combusta-bubble - Detect Barrier Target"
Event.OngoingPlayer
Team.Team1
Player.Zarya
if (pTalent1)
if (IsUsingAbility2(EventPlayer()))
{
	Wait(0.025, WaitBehavior.IgnoreCondition);
	pAbilityEnd = FilteredArray(PlayersWithinRadius(EventPlayer(), 30, Team.Team1, RadiusLOS.Surfaces), HasStatus(ArrayElement(), Status.Invincible) && IsAlive(ArrayElement()) && IsInViewAngle(EventPlayer(), ArrayElement(), 103))[0];
	WaitUntil(!IsUsingAbility2(EventPlayer()), 2);
	PlayEffect(AllPlayers(), PlayEffect.ExplosionSound, Color.Orange, pAbilityEnd, 120);
	PlayEffect(AllPlayers(), PlayEffect.GoodExplosion, Color.Orange, EyePosition(pAbilityEnd), 6);
	PlayEffect(AllPlayers(), PlayEffect.BadPickupEffect, Color.Yellow, EyePosition(pAbilityEnd), 6);
	Damage(PlayersWithinRadius(EyePosition(pAbilityEnd), 6, Team.Team2, RadiusLOS.Surfaces), pAbilityEnd, 100);
}

rule: "Zarya- Combusta-Bubble - Self bubble"
Event.OngoingPlayer
Team.Team1
Player.Zarya
if (pTalent1)
if (IsUsingAbility1(EventPlayer()))
{
	Wait(0.1, WaitBehavior.AbortWhenFalse);
	WaitUntil(!IsUsingAbility1(EventPlayer()), 2);
	PlayEffect(AllPlayers(), PlayEffect.ExplosionSound, Color.Orange, EventPlayer(), 120);
	PlayEffect(AllPlayers(), PlayEffect.GoodExplosion, Color.Orange, EventPlayer().EyePosition(), 6);
	PlayEffect(AllPlayers(), PlayEffect.BadPickupEffect, Color.Yellow, EventPlayer().EyePosition(), 6);
	Damage(PlayersWithinRadius(EventPlayer(), 6, Team.Team2, RadiusLOS.Surfaces), EventPlayer(), 100);
}

rule: "Zarya- Power Surge"
Event.OngoingPlayer
Team.Team1
Player.Zarya
if (pTalent2)
if (IsUsingAbility1(EventPlayer()))
{
	//> Can this be a condition
	AbortIf(!HasStatus(EventPlayer(), Status.Invincible));
	Damage(EventPlayer(), null, 10000);
	Wait(0.1, WaitBehavior.IgnoreCondition);
	SetAbilityCooldown(EventPlayer(), Button.Ability1, false);
	PressButton(EventPlayer(), Button.Ability1);
	Wait(3, WaitBehavior.IgnoreCondition);
}

rule: "Pharah: Head Trauma"
Event.PlayerDealtKnockback
Team.Team1
Player.Pharah
if (pTalent1)
if (EventAbility() == Button.Ability2)
if (!Victim().pIvIsPortal)
if (Victim() != EventPlayer())
{
	Damage(Victim(), EventPlayer(), 60);
	PlayEffect(AllPlayers(), PlayEffect.GoodExplosion, Color.Gray, Victim(), 1);
	AbortIf(NormalizedHealth(Victim()) > 0.5);
	SetStatus(Victim(), null, Status.Hacked, 1);
}

//> Broken
rule: "[Pharah] Weaponized Storm"
Event.OngoingPlayer
Team.Team1
Player.Pharah
if (pTalent2)
if (IsFiringPrimary(EventPlayer()))
if (!Ammo(EventPlayer(), false) % 6)
{
	SetProjectileSpeed(EventPlayer(), 125);
	pAbilityEnd = RayCastHitPosition(EventPlayer().EyePosition(), EventPlayer().EyePosition() + EventPlayer().FacingDirection() * 100, AllLivingPlayers(Team.All), EventPlayer(), true);
	pAbilityProjectile = EventPlayer().EyePosition();
	CreateEffect(AllPlayers(), Effect.BadAura, Color.Orange, pAbilityProjectile, 1, EffectRev.VisibleToPositionAndRadius);
	pEffects[7] = LastCreatedEntity();
	ChaseVariableAtRate(pAbilityProjectile, pAbilityEnd, 35, RateChaseReevaluation.DestinationAndRate);
	WaitUntil(!pTalent2 || pAbilityProjectile == pAbilityEnd, 99999);
	DestroyEffect(pEffects[7]);
	for (gIterator = 0; 6; 1)
	{
		PlayEffect(AllPlayers(), PlayEffect.BadPickupEffect, Color.Orange, pAbilityProjectile + Vector(RandomReal(-1.5, 1.5), RandomReal(-0.5, 0.5), RandomReal(-1.5, 1.5)), 1);
		PlayEffect(AllPlayers(), PlayEffect.ExplosionSound, Color.Team1, pAbilityProjectile, 25);
		Damage(PlayersWithinRadius(pAbilityProjectile, 4, Team.Team2, RadiusLOS.Surfaces), EventPlayer(), 20);
		Wait(0.1, WaitBehavior.IgnoreCondition);
	}
	SetProjectileSpeed(EventPlayer(), 100);
	StopChasingVariable(pAbilityProjectile);
}

rule: "Junkrat: Pyromania"
Event.PlayerDealtKnockback
Team.Team1
Player.Junkrat
if (pTalent1)
if (EventAbility() != Button.Melee)
if (Victim() != EventPlayer())
{
	StartDamageOverTime(Victim(), EventPlayer(), 2, 20);
	SetStatus(Victim(), null, Status.Burning, 2);
}

rule: "Junkrat: Trigger Happy"
Event.OngoingPlayer
Team.Team1
Player.Junkrat
if (pTalent2)
if (AbilityCharge(EventPlayer(), Button.Ability1) < 5)
{
	Wait(4, WaitBehavior.AbortWhenFalse);
	SetAbilityCharge(EventPlayer(), Button.Ability1, AbilityCharge(EventPlayer(), Button.Ability1) + 1);
	LoopIfConditionIsTrue();
}

rule: "Roadhog: Stench"
Event.OngoingPlayer
Team.Team1
Player.Roadhog
if (pTalent1)
if (IsAlive(EventPlayer()))
{
	CreateEffect(AllPlayers(), Effect.Ring, Color.Violet, EventPlayer(), 8, EffectRev.VisibleToPositionAndRadius);
	pEffects[1] = LastCreatedEntity();
	WaitUntil(!pTalent1 || EventPlayer().IsDead(), 99999);
	DestroyEffect(pEffects[1]);
	Wait(0.1, WaitBehavior.IgnoreCondition);
	LoopIfConditionIsTrue();
}

rule: "Roadhog: Stench effect"
Event.OngoingPlayer
Team.Team1
Player.Roadhog
if (DistanceBetween(EventPlayer(), ClosestPlayerTo(EventPlayer(), Team.Team2)) <= 8)
if (pTalent1)
{
	Damage(PlayersWithinRadius(EventPlayer(), 8, Team.Team2, RadiusLOS.Surfaces), EventPlayer(), 9);
	Wait(0.4, WaitBehavior.IgnoreCondition);
	LoopIfConditionIsTrue();
}

rule: "Roadhog: Chainsnap"
Event.OngoingPlayer
Team.Team1
Player.Roadhog
if (pTalent2)
if (IsUsingAbility1(EventPlayer()))
{
	pDamageDealt += 400;
	WaitUntil(!pTalent2 || !IsUsingAbility1(EventPlayer()), 99999);
	pDamageDealt -= 400;
	Wait(0.1, WaitBehavior.IgnoreCondition);
	LoopIfConditionIsTrue();
}

rule: "Roadhog: Chainsnap - Reset cooldown"
Event.OnElimination
Team.Team1
Player.Roadhog
if (pTalent2)
{
	WaitUntil(!IsUsingAbility1(EventPlayer()), 3);
	SetAbilityCooldown(EventPlayer(), Button.Ability1, false);
}

rule: "Moira: Flourish"
Event.OngoingPlayer
Team.Team1
Player.Moira
if (IsUsingAbility1(EventPlayer()))
if (pTalent1)
{
	StartDamageOverTime(PlayersWithinRadius(EventPlayer(), 3, Team.Team2, RadiusLOS.Surfaces), EventPlayer(), 2, 25);
	StartHealOverTime(PlayersWithinRadius(EventPlayer(), 3, Team.Team1, RadiusLOS.Surfaces), EventPlayer(), 2, 40);
	PlayEffect(AllPlayers(), PlayEffect.RingExplosion, Color.Black, EventPlayer().Position(), 6);
	Wait(0.2, WaitBehavior.IgnoreCondition);
	LoopIfConditionIsTrue();
}

rule: "[Moira] Catalyst -"
Event.OngoingPlayer
Team.Team1
Player.Moira
if (pTalent2)
if (IsUsingUltimate(EventPlayer()))
if (IsButtonHeld(EventPlayer(), Button.PrimaryFire))
if (AbilityResource(EventPlayer(), Button.PrimaryFire) > 8)
{
	pDamageDealt += 300;
	pHealingDealtPercent += 300;
	pMoveSpeed -= 40;
	WaitUntil(!IsButtonHeld(EventPlayer(), Button.PrimaryFire) || !pTalent2 || !IsUsingUltimate(EventPlayer()), 8);
	pDamageDealt -= 300;
	pMoveSpeed += 40;
	pHealingDealtPercent -= 300;
	Wait(0.25, WaitBehavior.IgnoreCondition);
}

rule: "[Moira] Catalyst -"
Event.OngoingPlayer
Team.Team1
Player.Moira
if (pTalent2)
if (IsUsingUltimate(EventPlayer()))
if (IsButtonHeld(EventPlayer(), Button.PrimaryFire))
if (AbilityResource(EventPlayer(), Button.PrimaryFire) > 8)
{
	SetAbilityResource(EventPlayer(), Button.PrimaryFire, AbilityResource(EventPlayer(), Button.PrimaryFire) - 15);
	PlayEffect(AllPlayers(), PlayEffect.RingExplosion, Color.Purple, EventPlayer().EyePosition(), 10);
	Damage(PlayersWithinRadius(EventPlayer().EyePosition(), 5, Team.Team2, RadiusLOS.Surfaces), EventPlayer(), 35);
	Wait(0.5, WaitBehavior.IgnoreCondition);
	LoopIfConditionIsTrue();
}

rule: "Mei: Cold Snap"
Event.OngoingPlayer
Team.Team1
Player.Mei
if (pTalent1)
if (IsUsingAbility1(EventPlayer()))
{
	Wait(0.5, WaitBehavior.AbortWhenFalse);
	WaitUntil(!IsUsingAbility1(EventPlayer()), 99999);
	Damage(PlayersWithinRadius(EventPlayer().EyePosition(), 10, Team.Team2, RadiusLOS.Surfaces), EventPlayer(), 35);
	SetStatus(PlayersWithinRadius(EventPlayer().EyePosition(), 10, Team.Team2, RadiusLOS.Surfaces), EventPlayer(), Status.Frozen, 2);
	PlayEffect(AllPlayers(), PlayEffect.RingExplosion, Color.SkyBlue, EventPlayer().Position(), 20);
	PlayEffect(AllPlayers(), PlayEffect.RingExplosion, Color.Aqua, EventPlayer().Position() + Vector(0, 1, false), 20);
}

rule: "[Mei] Fractical Strike"
Event.OngoingPlayer
Team.Team1
Player.Mei
if (pTalent2)
if (IsFiringSecondary(EventPlayer()))
{
	pDamageDealt -= 60;
	Wait(0.3, WaitBehavior.IgnoreCondition);
	pDamageDealt += 60;
	AbortIfConditionIsFalse();
	for (gIterator = 0; 5; 1)
	{
		CreateProjectile(ProjectileType.MeiIcicle, EventPlayer(), EventPlayer().EyePosition() + WorldVectorOf(Vector(false, -0.25, false), EventPlayer(), LocalVector.Rotation), DirectionFromAngles(HorizontalFacingAngleOf(EventPlayer()) + RandomReal(-8, 8), VerticalFacingAngleOf(EventPlayer()) + RandomReal(-8, 8)), Relative.ToWorld, ModifyHealthType.Damage, Team.Team2, 75, 2, 0, PlayEffect.BadExplosion, PlayEffect.ExplosionSound, 0, 115, 5, 0, 0, 5);
		CreateProjectile(ProjectileType.MeiIcicle, EventPlayer(), EventPlayer().EyePosition() + WorldVectorOf(Vector(false, -0.25, false), EventPlayer(), LocalVector.Rotation), DirectionFromAngles(HorizontalFacingAngleOf(EventPlayer()) + RandomReal(-8, 8), VerticalFacingAngleOf(EventPlayer()) + RandomReal(-8, 8)), Relative.ToWorld, ModifyHealthType.Damage, Team.Team2, 75, 2, 0, PlayEffect.BadExplosion, PlayEffect.ExplosionSound, 0, 115, 5, 0, 0, 5);
	}
}

rule: "[Winston] Next Generation"
Event.PlayerDealtKnockback
Team.Team1
Player.Winston
if (pTalent1)
if (EventAbility() == Button.Ultimate)
{
	SetUltimateCharge(EventPlayer(), UltimateChargePercent(EventPlayer()) + 5);
	Damage(Victim(), EventPlayer(), EventDamage());
}

rule: "[Winston] Quake"
Event.OngoingPlayer
Team.Team1
Player.Winston
if (pTalent2)
if (IsUsingAbility1(EventPlayer()))
{
	Wait(0.25, WaitBehavior.IgnoreCondition);
	WaitUntil(IsOnGround(EventPlayer()), 99999);
	AbortIf(EventPlayer().IsDead());
	Damage(PlayersWithinRadius(EventPlayer(), 7.5, Team.Team2, RadiusLOS.SurfacesAndAllBarriers), EventPlayer(), 30);
	PlayEffect(AllPlayers(), PlayEffect.RingExplosion, Color.White, EventPlayer().Position(), 15);
	PlayEffect(AllPlayers(), PlayEffect.RingExplosion, Color.Gray, EventPlayer().Position(), 14);
	SetStatus(PlayersWithinRadius(EventPlayer(), 7.5, Team.Team2, RadiusLOS.SurfacesAndAllBarriers), EventPlayer(), Status.Stunned, 1);
}

rule: "Reaper: Wraith Wrath"
Event.OngoingPlayer
Team.Team1
Player.Reaper
if (IsUsingAbility1(EventPlayer()))
if (pTalent1)
{
	Wait(0.1, WaitBehavior.AbortWhenFalse);
	CancelPrimaryAction(EventPlayer());
	CreateEffect(AllPlayers(), Effect.ReaperWraithFormEffect, Color.Team1, EventPlayer(), true, EffectRev.VisibleToPositionAndRadius);
	pEffects[1] = LastCreatedEntity();
	pDamageDealt += 30;
	pMoveSpeed += 50;
	DisallowButton(EventPlayer(), Button.Ability1);
	SetStatus(EventPlayer(), null, Status.PhasedOut, 3);
	WaitUntil(EventPlayer().IsDead() || !pTalent1, 3);
	AllowButton(EventPlayer(), Button.Ability1);
	SetAbilityCooldown(EventPlayer(), Button.Ability1, 8);
	pDamageDealt -= 30;
	pMoveSpeed -= 50;
	DestroyEffect(pEffects[1]);
}

rule: "Reaper: Loom"
Event.OngoingPlayer
Team.Team1
Player.Reaper
if (IsUsingAbility1(EventPlayer()))
if (pTalent2)
{
	SetStatus(FilteredArray(PlayersInViewAngle(EventPlayer(), Team.Team2, 45), IsInLineOfSight(EventPlayer(), ArrayElement(), BarrierLOS.NoBarriersBlock)), EventPlayer(), Status.Hacked, 2);
	Damage(FilteredArray(PlayersInViewAngle(EventPlayer(), Team.Team2, 45), IsInLineOfSight(ArrayElement(), EventPlayer(), BarrierLOS.NoBarriersBlock)), EventPlayer(), 35);
}

rule: "[Sojourn] Thunderout Kicks"
Event.OngoingPlayer
Team.Team1
Player.Sojourn
if (pTalent1)
if (IsUsingAbility1(EventPlayer()))
{
	pAbilityActive = 1 + TotalTimeElapsed();
	WaitUntil(AbilityCooldown(EventPlayer(), Button.Ability1) > 1 || IsButtonHeld(EventPlayer(), Button.Jump), 1);
	AbortIf(pAbilityActive < TotalTimeElapsed());
	PlayEffect(AllPlayers(), PlayEffect.RingExplosion, Color.Turquoise, EventPlayer().Position(), 12);
	Damage(PlayersWithinRadius(EventPlayer(), 6, Team.Team2, RadiusLOS.Surfaces), EventPlayer(), 75);
}

rule: "Sojourn: Matter Splatter"
Event.OnDamageDealt
Team.Team1
Player.Sojourn
if (pTalent2)
if (EventAbility() == Button.SecondaryFire)
if (EventWasCriticalHit())
{
	PlayEffect(AllPlayers(), PlayEffect.BadExplosion, Color.Turquoise, EyePosition(Victim()), 4);
	Damage(PlayersWithinRadius(Victim(), 4, Team.Team2, RadiusLOS.Surfaces), EventPlayer(), EventDamage());
}

rule: "Soldier76: Triple Threat"
Event.OngoingPlayer
Team.Team1
Player.Soldier76
if (pTalent1)
if (IsFiringSecondary(EventPlayer()))
{
	CreateProjectile(ProjectileType.PharahRocket, EventPlayer(), null, DirectionFromAngles(HorizontalFacingAngleOf(EventPlayer()) + 4.5, VerticalFacingAngleOf(EventPlayer())), Relative.ToWorld, ModifyHealthType.Damage, Team.Team2, 60, 1, 2.5, PlayEffect.GoodExplosion, PlayEffect.RingExplosionSound, 0, 60, 4, 0, 0, 0);
	CreateProjectile(ProjectileType.PharahRocket, EventPlayer(), null, DirectionFromAngles(HorizontalFacingAngleOf(EventPlayer()) - 4.5, VerticalFacingAngleOf(EventPlayer())), Relative.ToWorld, ModifyHealthType.Damage, Team.Team2, 60, 1, 2.5, PlayEffect.GoodExplosion, PlayEffect.RingExplosionSound, 0, 60, 4, 0, 0, 0);
}

rule: "Soldier76: Triple Threat - Init rocket"
Event.OngoingPlayer
Team.Team1
Player.Soldier76
if (pTalent1)
{
	//> So fucking wrong
	pAbilityProjectile = pAbilityAvailable;
	pAbilityCountdown = pAbilityEnd;
}

rule: "Soldier76: Espionage"
Event.OnHealingDealt
Team.Team1
Player.Soldier76
if (pTalent2)
if (EventAbility() == Button.Ability2)
{
	if (!Healee().pSoldierEspionage)
	{
		Healee().pSoldierEspionage = true;
	}
}

rule: "Soldier76: Espionage - Allies effect"
Event.OngoingPlayer
Team.Team1
if (pSoldierEspionage)
{
	pSoldierEspionage = false;
	if (pDownedStartT && CountOf(pRevivers) > 0)
	{
		pReviveTimer += 20;
	}
	pActiveAbIsSmoked = true;
	Wait(0.4, WaitBehavior.IgnoreCondition);
}

rule: "Baptiste: Corrode"
Event.OngoingPlayer
Team.Team1
Player.Baptiste
if (IsUsingAbility1(EventPlayer()))
if (pTalent1)
{
	for (gIterator = 0; 3; 1)
	{
		PlayEffect(AllPlayers(), PlayEffect.RingExplosion, Color.Purple, EventPlayer().Position(), 20);
		Damage(PlayersWithinRadius(EventPlayer(), 10, Team.Team2, RadiusLOS.Surfaces), EventPlayer(), 25);
		StartDamageOverTime(PlayersWithinRadius(EventPlayer(), 10, Team.Team2, RadiusLOS.Surfaces), EventPlayer(), 5, 30);
		Wait(0.2, WaitBehavior.IgnoreCondition);
	}
}

rule: "[Baptiste] Aerial Ace - Jump"
Event.OngoingPlayer
Team.Team1
Player.Baptiste
if (pTalent2)
if (IsCrouching(EventPlayer()))
if (!HasStatus(EventPlayer(), Status.Hacked))
{
	WaitUntil(!IsCrouching(EventPlayer()), 9999);
	WaitUntil(IsJumping(EventPlayer()), 1);
	pAbilityAvailable = true;
	Wait(0.25, WaitBehavior.IgnoreCondition);
	pDamageDealt += 50;
	WaitUntil(IsOnGround(EventPlayer()), 99999);
	pAbilityAvailable = false;
	pDamageDealt -= 50;
}

rule: "[Baptiste] Aerial Ace - Slower fall"
Event.OngoingPlayer
Team.Team1
Player.Baptiste
if (pTalent2)
if (pAbilityAvailable)
if (IsAlive(EventPlayer()))
if (IsButtonHeld(EventPlayer(), Button.Jump))
if (!HasStatus(EventPlayer(), Status.Stunned) && HasStatus(EventPlayer(), Status.Hacked))
if (AltitudeOf(EventPlayer()) >= 1)
if (VerticalSpeedOf(EventPlayer()) < 0)
{
	SetGravity(EventPlayer(), 7.5);
	Wait(0.333, WaitBehavior.IgnoreCondition);
	PlayEffect(AllPlayers(TeamOf(EventPlayer())), PlayEffect.RingExplosion, Color.Orange, EventPlayer().Position(), 2);
	LoopIfConditionIsTrue();
	SetGravity(EventPlayer(), 100);
}

rule: "[Bastion]- Fusillade"
Event.OngoingPlayer
Team.Team1
Player.Bastion
if (pTalent1)
if (IsInAlternateForm(EventPlayer()))
if (IsFiringPrimary(EventPlayer()))
{
	Wait(0.5, WaitBehavior.AbortWhenFalse);
	while (IsFiringPrimary(EventPlayer()) && IsInAlternateForm(EventPlayer()))
	{
		CreateProjectile(ProjectileType.PharahRocket, EventPlayer(), EventPlayer().EyePosition() + WorldVectorOf(Vector(RandomReal(-0.4, 0.4), RandomReal(-0.4, -0.4), 0), EventPlayer(), LocalVector.Rotation), null, Relative.ToWorld, ModifyHealthType.Damage, Team.Team2, 25, 1, 1.5, PlayEffect.GoodExplosion, PlayEffect.ExplosionSound, 0, 35, 2, 0, 0, 0);
		Wait(0.25, WaitBehavior.IgnoreCondition);
	}
}

rule: "[Bastion]: Trickshot"
Event.OnDamageDealt
Team.Team1
Player.Bastion
if (pTalent2)
if (EventAbility() == Button.SecondaryFire)
if (EventDamage() <= 30)
{
	Wait(0.5, WaitBehavior.IgnoreCondition);
	SetAbilityCooldown(EventPlayer(), Button.SecondaryFire, AbilityCooldown(EventPlayer(), Button.SecondaryFire) - 3);
	Damage(PlayersWithinRadius(Victim(), 5, Team.Team2, RadiusLOS.Surfaces), EventPlayer(), 30);
	Heal(EventPlayer(), EventPlayer(), 50);
}

rule: "[Sombra] Stack Overflow"
Event.OngoingPlayer
Team.Team1
Player.Sombra
if (pTalent1)
if (IsUsingAbility1(EventPlayer()))
{
	Wait(0.8, WaitBehavior.AbortWhenFalse);
	WaitUntil(IsButtonHeld(EventPlayer(), Button.PrimaryFire) || IsButtonHeld(EventPlayer(), Button.Ability1) || IsButtonHeld(EventPlayer(), Button.Ultimate) || IsButtonHeld(EventPlayer(), Button.Melee) || IsCommunicatingAnyEmote(EventPlayer()), 99999);
	CancelPrimaryAction(EventPlayer());
	CreateEffect(EventPlayer(), Effect.MercyDamageBoostedEffect, Color.Team1, EventPlayer(), 1, EffectRev.VisibleToPositionRadiusAndColor);
	pDamageDealt += 50;
	pEffects[1] = LastCreatedEntity();
	pAbilityActive = true;
	WaitUntil(EventPlayer().IsDead() || !pTalent1, 3);
	pDamageDealt -= 50;
	DestroyEffect(pEffects[1]);
	pAbilityActive = false;
}

rule: "[Sombra] Stack Overflow - melee"
Event.PlayerDealtKnockback
Team.Team1
Player.Sombra
if (pTalent1)
if (pAbilityActive)
if (EventAbility() == Button.Melee)
{
	SetStatus(Victim(), EventPlayer(), Status.Stunned, 1);
	Damage(Victim(), EventPlayer(), 40);
	PlayEffect(AllPlayers(), PlayEffect.BadExplosion, Color.Purple, Victim(), 0.25);
}

rule: "[Sombra] Cyberattack"
Event.OngoingPlayer
Team.Team1
Player.Sombra
if (pTalent2)
if (IsUsingAbility2(EventPlayer()))
{
	WaitUntil(!IsUsingAbility2(EventPlayer()), 99999);
	AbortIf(IsButtonHeld(EventPlayer(), Button.Interact));
	AbortIf(EventPlayer().IsDead());
	Wait(0.25, WaitBehavior.IgnoreCondition);
	Damage(PlayersWithinRadius(EventPlayer(), 8, Team.Team2, RadiusLOS.Surfaces), EventPlayer(), 50);
	PlayEffect(AllPlayers(), PlayEffect.RingExplosionSound, Color.White, EventPlayer().EyePosition(), 20000);
	PlayEffect(AllPlayers(), PlayEffect.GoodExplosion, Color.Purple, EventPlayer().EyePosition(), 8);
	PlayEffect(AllPlayers(), PlayEffect.RingExplosion, Color.Violet, EventPlayer().EyePosition(), 16);
	SetStatus(PlayersWithinRadius(EventPlayer().EyePosition(), 8, Team.Team2, RadiusLOS.Surfaces), EventPlayer(), Status.Hacked, 2);
}

rule: "Doomfist: Punch Card"
Event.OngoingPlayer
Team.Team1
Player.Doomfist
if (pTalent1)
if (IsFiringSecondary(EventPlayer()))
{
	Wait(1, WaitBehavior.AbortWhenFalse);
	pDamageDealt += 200;
	WaitUntil(AbilityCooldown(EventPlayer(), Button.SecondaryFire) > 0.1, 1);
	pDamageDealt -= 200;
}

rule: "[Doomfist] Fire Quake - Use seismic slam"
Event.OngoingPlayer
Team.Team1
Player.Doomfist
if (pTalent2)
if (IsUsingAbility1(EventPlayer()))
{
	Wait(0.5, WaitBehavior.IgnoreCondition);
	WaitUntil(IsOnGround(EventPlayer()) || !IsUsingAbility1(EventPlayer()), 1000);
	AbortIf(!IsUsingAbility1(EventPlayer()));
	for (gIterator = -5; 5; 1)
	{
		CreateProjectile(ProjectileType.ReinhardtFireStrike, EventPlayer(), null, DirectionFromAngles(HorizontalFacingAngleOf(EventPlayer()) + gIterator * 5, VerticalFacingAngleOf(EventPlayer())), Relative.ToWorld, ModifyHealthType.Damage, Team.Team2, 50, 1, 0, PlayEffect.GoodExplosion, PlayEffect.ExplosionSound, 0, 40, 4, 0, 0, 0);
		Wait(0.025, WaitBehavior.IgnoreCondition);
	}
	for (gIterator = 5; -5; -1)
	{
		CreateProjectile(ProjectileType.ReinhardtFireStrike, EventPlayer(), null, DirectionFromAngles(HorizontalFacingAngleOf(EventPlayer()) + gIterator * 5, VerticalFacingAngleOf(EventPlayer())), Relative.ToWorld, ModifyHealthType.Damage, Team.Team2, 50, 1, 0, PlayEffect.GoodExplosion, PlayEffect.ExplosionSound, 0, 40, 4, 0, 0, 0);
		Wait(0.025, WaitBehavior.IgnoreCondition);
	}
}

rule: "Cassidy: Standoff"
Event.OngoingPlayer
Team.Team1
Player.Cassidy
if (IsUsingUltimate(EventPlayer()))
if (pTalent1)
{
	Wait(0.2, WaitBehavior.IgnoreCondition);
	pAbilityCountdown = false;
	ChaseVariableAtRate(pAbilityCountdown, 9999, 100, RateChaseReevaluation.DestinationAndRate);
	Wait(0.5, WaitBehavior.IgnoreCondition);
	ChaseVariableAtRate(pAbilityCountdown, 9999, 275, RateChaseReevaluation.DestinationAndRate);
	Wait(0.5, WaitBehavior.IgnoreCondition);
	ChaseVariableAtRate(pAbilityCountdown, 9999, 550, RateChaseReevaluation.DestinationAndRate);
}

rule: "Cassidy: Standoff - Set root"
Event.OngoingPlayer
Team.Team1
Player.Cassidy
if (IsUsingUltimate(EventPlayer()))
if (pTalent1)
{
	Wait(0.2, WaitBehavior.IgnoreCondition);
	for (gIterator = 0; 5; 1)
	{
		Wait(1, WaitBehavior.AbortWhenFalse);
		PlayEffect(EventPlayer(), PlayEffect.ExplosionSound, Color.White, EventPlayer(), 15);
		SetStatus(FilteredArray(PlayersInViewAngle(EventPlayer(), Team.Team2, 103), Health(ArrayElement()) <= pAbilityCountdown && IsInLineOfSight(EventPlayer(), ArrayElement(), BarrierLOS.NoBarriersBlock)), EventPlayer(), Status.Rooted, 2);
	}
	StopChasingVariable(pAbilityCountdown);
}

rule: "Cassidy: Flashpoint"
Event.OnDamageDealt
Team.Team1
Player.Cassidy
if (pTalent2)
if (EventAbility() == Button.Ability2)
{
	if (EventDamage() <= 25)
	{
		Wait(1.25, WaitBehavior.IgnoreCondition);
		Damage(PlayersWithinRadius(Victim(), 8, Team.Team2, RadiusLOS.Surfaces), EventPlayer(), 35);
		SetStatus(PlayersWithinRadius(Victim(), 8, Team.Team2, RadiusLOS.Surfaces), EventPlayer(), Status.Stunned, 2);
	}
}

rule: "Wrecking Ball: Orbital Strike"
Event.OngoingPlayer
Team.Team1
Player.WreckingBall
if (pTalent1)
if (AbilityCooldown(EventPlayer(), Button.Crouch) >= 0.1)
{
	pAbilityCountdown = AltitudeOf(EventPlayer()) * 10;
	pDamageDealt += pAbilityCountdown;
	WaitUntil(IsOnGround(EventPlayer()) || EventPlayer().IsDead(), 9999);
	Wait(1, WaitBehavior.IgnoreCondition);
	pDamageDealt -= pAbilityCountdown;
}

rule: "[Wrecking Ball] Orbital Strike"
Event.PlayerDealtKnockback
Team.Team1
Player.WreckingBall
if (pTalent1)
if (EventAbility() == Button.Crouch)
{
	SetStatus(Victim(), null, Status.Stunned, 1.1);
}

rule: "Wrecking Ball: Distort"
Event.OngoingPlayer
Team.Team1
Player.WreckingBall
if (pTalent2)
if (IsUsingAbility2(EventPlayer()))
{
	for (gIterator = false; 4; 1)
	{
		PlayEffect(AllPlayers(), PlayEffect.RingExplosion, Color.Purple, EventPlayer().Position(), 20);
		Damage(PlayersWithinRadius(EventPlayer(), 10, Team.Team2, RadiusLOS.Surfaces), EventPlayer(), 25);
		SetStatus(PlayersWithinRadius(EventPlayer(), 10, Team.Team2, RadiusLOS.Surfaces), EventPlayer(), Status.Hacked, 2);
		Wait(0.1, WaitBehavior.IgnoreCondition);
	}
}

rule: "[Queen] Shout Very Loudly"
Event.OngoingPlayer
Team.Team1
Player.JunkerQueen
if (pTalent1)
if (IsUsingAbility1(EventPlayer()))
{
	StartDamageOverTime(RemoveFromArray(PlayersWithinRadius(EventPlayer(), 15, Team.Team2, RadiusLOS.Surfaces), EventPlayer()), EventPlayer(), 5, 8);
	StartHealOverTime(EventPlayer(), EventPlayer(), 5, 8 * CountOf(PlayersWithinRadius(EventPlayer(), 15, Team.Team2, RadiusLOS.Surfaces)));
}

rule: "[Queen] Grace Period"
Event.PlayerDealtKnockback
Team.Team1
Player.JunkerQueen
if (pTalent2)
if (EventAbility() == Button.SecondaryFire)
if (!IsMeleeing(EventPlayer()))
{
	Damage(PlayersWithinRadius(Victim(), 6, Team.Team2, RadiusLOS.Surfaces), EventPlayer(), 50);
	Heal(EventPlayer(), EventPlayer(), 50);
	StartDamageOverTime(PlayersWithinRadius(Victim(), 6, Team.Team2, RadiusLOS.Surfaces), EventPlayer(), 3, 25);
	StartHealOverTime(EventPlayer(), EventPlayer(), 3, 25);
	ApplyImpulse(RemoveFromArray(PlayersWithinRadius(Victim(), 6, Team.Team2, RadiusLOS.Surfaces), Victim()), DirectionTowards(Victim(), EventPlayer()), 20, Relative.ToWorld, ContraryMotion.Cancel);
	ApplyImpulse(RemoveFromArray(PlayersWithinRadius(Victim(), 6, Team.Team2, RadiusLOS.Surfaces), Victim()), Up(), 6, Relative.ToWorld, ContraryMotion.Cancel);
	SetStatus(PlayersWithinRadius(Victim(), 6, Team.Team2, RadiusLOS.Surfaces), null, Status.Rooted, 0.8);
}

rule: "Kiriko: Shinobi Tactics"
Event.OnHealingDealt
Team.Team1
Player.Kiriko
if (pTalent1)
{
	Damage(PlayersWithinRadius(Healee(), 6, Team.Team2, RadiusLOS.Surfaces), EventPlayer(), EventHealing() * 2);
}

rule: "Kiriko: Recession"
Event.PlayerDealtKnockback
Team.Team1
Player.Kiriko
if (pTalent2)
if (EventAbility() == Button.Ability2)
{
	Damage(Victim(), EventPlayer(), 75);
	SetStatus(Victim(), EventPlayer(), Status.Frozen, 1.5);
	PlayEffect(AllPlayers(), PlayEffect.GoodExplosion, Color.Gray, Victim(), 1);
}

rule: "Ramattra: Vile Dominance"
Event.OngoingPlayer
Team.Team1
Player.Ramattra
if (pTalent1)
if ((IsUsingAbility1(EventPlayer()) || IsUsingUltimate(EventPlayer())))
{
	pMoveSpeed += 30;
	pAbilityActive = true;
	WaitUntil(!IsUsingAbility1(EventPlayer()) && !IsUsingUltimate(EventPlayer()) || !pTalent1, 9999);
	pMoveSpeed -= 30;
	pAbilityActive = false;
}

//> Stupid
rule: "Ramattra: Vile Dominance"
Event.OnDamageDealt
Team.Team1
Player.Ramattra
{
	AbortIf(!pAbilityActive);
	AbortIf(EventAbility() == null);
	AbortIf(EventAbility() == Button.Ability2);
	AbortIf(EventAbility() == Button.Ultimate);
	SetStatus(Victim(), EventPlayer(), Status.Rooted, 0.75);
}

rule: "Ramattra: Nether Sector"
Event.OnDamageDealt
Team.Team1
Player.Ramattra
if (pTalent2)
if (EventAbility() == Button.Ability2)
if (IsOnGround(Victim()))
{
	SetUltimateCharge(EventPlayer(), UltimateChargePercent(EventPlayer()) + 1);
	Wait(0.1, WaitBehavior.IgnoreCondition);
}

rule: "Lifeweaver: Autumn Blossoms"
Event.OnElimination
Team.Team1
Player.Lifeweaver
if (pTalent1)
{
	CreateProjectile(ProjectileType.ZaryaParticleCannon, null, PositionOf(Victim()) + Vector(0, 0.5, 0), Up(), Relative.ToWorld, ModifyHealthType.Heal, Team.Team1, MaxHealth(Victim()), 1, 0, PlayEffect.BadExplosion, PlayEffect.ExplosionSound, 0.025, 0, 8, 0, 0, 0);
}

rule: "Team 1 Lifeweaver: Increased damage"
Event.OngoingPlayer
Team.Team1
Player.Lifeweaver
{
	pDamageDealt += 30;
	WaitUntil(pPerkMysterySwap >= TotalTimeElapsed() + 90 || !pTalent1, 99999);
	pDamageDealt -= 30;
}

rule: "Lifeweaver: Pressure Therapy"
Event.OngoingPlayer
Team.Team1
Player.Lifeweaver
if (pTalent2)
if (IsAlive(EventPlayer()))
{
	Wait(0.5, WaitBehavior.AbortWhenFalse);
	StartDamageModification(FilteredArray(AllPlayers(Team.Team2), YOf(EventPlayer().Position()) - YOf(PositionOf(ArrayElement())) >= 3 || DotProduct(FacingDirectionOf(ArrayElement()), VectorTowards(ArrayElement(), EventPlayer())) < 0), EventPlayer(), 150, DamageModificationRev.ReceiversDamagersAndDamagePercent);
	pDamageMod[1] = LastDamageModificationID();
	WaitUntil(!pTalent2 || EventPlayer().IsDead(), 99999);
	StopDamageModification(pDamageMod[1]);
	Wait(0.1, WaitBehavior.IgnoreCondition);
	LoopIfConditionIsTrue();
}
