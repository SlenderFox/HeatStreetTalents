import "globalvars.ostw";
import "playervars.ostw";
import "subroutines.ostw";

globalvar Boolean gIsHardModeEnabled;
globalvar Boolean gMutDeepWounds;
globalvar Number gMoneyMult;
globalvar Vector gBuyMenuCamPos;
globalvar Vector gPlayerSpawnPos;
globalvar Vector gPlayerSpawnFacing;
globalvar Vector gAbilityShopPos;
globalvar String[] gProgressBarStrings;

playervar Number pHealMod;
playervar Number[] pDamageReceived;
playervar Number pActiveAbNumber;
playervar Number pActiveAbCooldown;
playervar Vector pDeathCamTarget;
playervar Player pSpectatedPlayer;
playervar Any pNemesisBeamEffect;
playervar Any pActiveAbVar; // Both vector and player

void open_buy_menu() "Subroutine: Open Buy Menu, Last Facing (3)"
{
	AbortIf(pDownedStartT || NormalizedHealth(EventPlayer()) < 0.5 || HasStatus(EventPlayer(), Status.Stunned) || pTasedEndT >= TotalTimeElapsed());
	ApplyImpulse(EventPlayer(), -1 * DirectionFromAngles(HorizontalAngleFromDirection(VelocityOf(EventPlayer())), false), 0.001, Relative.ToWorld, ContraryMotion.CancelXYZ);
	pAbVar3 = FacingDirectionOf(EventPlayer());
	pInBuyMenu = TotalTimeElapsed();
	DisableHeroHud(EventPlayer());
	SetFacing(EventPlayer(), Forward(), Relative.ToWorld);
	StartCamera(EventPlayer(), gBuyMenuCamPos, gBuyMenuCamPos + gBuyMenuLeftUpForward[2], 0);
	disable_player();
	SetAimSpeed(EventPlayer(), 200);
}

void leave_buy_menu() "Subroutine: Leave Buy Menu"
{
	pInBuyMenu = false;
	EnableHeroHud(EventPlayer());
	SetFacing(EventPlayer(), pAbVar3, Relative.ToWorld);
	if (!pDownedStartT)
	{
		StopCamera(EventPlayer());
		enable_player();
	}
	SetAimSpeed(EventPlayer(), 100);
}

void check_if_enough_money() "Subroutine: Check if enough money"
{
	if (gMoneyMult * gMoneyAmount - pMoneySpentAmount >= gTemp2)
	{
		pMoneySpentAmount += gTemp2;
		SmallMessage(EventPlayer(), "Ability unlocked");
		play_purchase_confirmation_sound();
	}
	else
	{
		gTemp2 = false;
		SmallMessage(EventPlayer(), "Not enough money");
	}
}

void buy_active_ability() "Subroutine: Buy Active Ability"
{
	if (!pActiveAbNumber)
	{
		gTemp2 = 1200;
		check_if_enough_money();
		AbortIf(!gTemp2);
	}
	else if (gTemp1 == pActiveAbNumber)
	{
		Abort();
	}
	else
	{
		SmallMessage(EventPlayer(), "Swapped Active Ability");
	}
	remove_active_ability();
	pActiveAbNumber = gTemp1;
	if (gTemp1 == 1)
	{
		CreateEffect(pActiveAbCooldown < 0 ? AllPlayers(Team.All) : [], Effect.AnaNanoBoostedEffect, Color.Team1, EventPlayer(), 1, EffectRev.VisibleTo);
		ModifyVariable(pActiveAbEffectList, Operation.AppendToArray, LastCreatedEntity());
	}
	else if (gTemp1 == 2)
	{
		CreateEffect(pActiveAbCooldown < 0 ? AllPlayers(Team.All) : [], Effect.ReaperWraithFormEffect, Color.Team1, EventPlayer(), 1, EffectRev.VisibleTo);
		ModifyVariable(pActiveAbEffectList, Operation.AppendToArray, LastCreatedEntity());
	}
	else if (gTemp1 == 4)
	{
		CreateEffect(pActiveAbCooldown < 0 ? AllPlayers(Team.All) : [], Effect.BaptisteImmortalityFieldProtectedEffect, Color.Team1, EventPlayer(), 1, EffectRev.VisibleTo);
		ModifyVariable(pActiveAbEffectList, Operation.AppendToArray, LastCreatedEntity());
	}
	else if (gTemp1 == 5)
	{
		pActiveAbVar = 1000 * Down();
		CreateEffect(pActiveAbCooldown < 0 ? AllPlayers(Team.All) : [], Effect.Cloud, Color.SkyBlue, pActiveAbVar + 2 * Up(), 10, EffectRev.VisibleToPositionAndRadius);
		ModifyVariable(pActiveAbEffectList, Operation.AppendToArray, LastCreatedEntity());
		CreateEffect(pActiveAbCooldown < 0 ? AllPlayers(Team.All) : [], Effect.Cloud, Color.SkyBlue, pActiveAbVar + 2 * Down(), 10, EffectRev.VisibleToPositionAndRadius);
		ModifyVariable(pActiveAbEffectList, Operation.AppendToArray, LastCreatedEntity());
		CreateEffect(pActiveAbCooldown < 0 ? AllPlayers(Team.All) : [], Effect.Ring, Color.SkyBlue, pActiveAbVar + Down(), 10, EffectRev.VisibleToPositionAndRadius);
		ModifyVariable(pActiveAbEffectList, Operation.AppendToArray, LastCreatedEntity());
	}
	else if (gTemp1 == 6)
	{
		CreateEffect(pActiveAbCooldown < 0 ? AllPlayers(Team.All) : [], Effect.HealTargetActiveEffect, Color.Team1, EventPlayer(), 1, EffectRev.VisibleTo);
		ModifyVariable(pActiveAbEffectList, Operation.AppendToArray, LastCreatedEntity());
	}
	else if (gTemp1 == 7)
	{
		pActiveAbVar = 1000 * Down();
		CreateEffect(pActiveAbCooldown < 0 ? AllPlayers(Team.All) : [], Effect.Cloud, Color.Yellow, pActiveAbVar + Up(), 8, EffectRev.VisibleToPositionAndRadius);
		ModifyVariable(pActiveAbEffectList, Operation.AppendToArray, LastCreatedEntity());
		CreateEffect(pActiveAbCooldown < 0 ? AllPlayers(Team.All) : [], Effect.Cloud, Color.Yellow, pActiveAbVar + Down(), 8, EffectRev.VisibleToPositionAndRadius);
		ModifyVariable(pActiveAbEffectList, Operation.AppendToArray, LastCreatedEntity());
	}
	else if (gTemp1 == 8)
	{
		pActiveAbVar = [];
		CreateBeamEffect(CountOf(pActiveAbVar) ? AllPlayers(Team.All) : [], BeamType.BadBeam, EventPlayer(), pActiveAbVar[0], Color.Purple, EffectRev.VisibleToPositionAndRadius);
		ModifyVariable(pActiveAbEffectList, Operation.AppendToArray, LastCreatedEntity());
		CreateBeamEffect(CountOf(pActiveAbVar) > 1 ? AllPlayers(Team.All) : [], BeamType.BadBeam, pActiveAbVar[0], pActiveAbVar[1], Color.Purple, EffectRev.VisibleToPositionAndRadius);
		ModifyVariable(pActiveAbEffectList, Operation.AppendToArray, LastCreatedEntity());
		CreateBeamEffect(CountOf(pActiveAbVar) > 2 ? AllPlayers(Team.All) : [], BeamType.BadBeam, pActiveAbVar[1], pActiveAbVar[2], Color.Purple, EffectRev.VisibleToPositionAndRadius);
		ModifyVariable(pActiveAbEffectList, Operation.AppendToArray, LastCreatedEntity());
		CreateBeamEffect(CountOf(pActiveAbVar) > 3 ? AllPlayers(Team.All) : [], BeamType.BadBeam, pActiveAbVar[2], pActiveAbVar[3], Color.Purple, EffectRev.VisibleToPositionAndRadius);
		ModifyVariable(pActiveAbEffectList, Operation.AppendToArray, LastCreatedEntity());
	}
	play_purchase_confirmation_sound();
}

void remove_active_ability() "Subroutine: Remove Active Ability"
{
	if (pActiveAbCooldown < 0)
	{
		pActiveAbCooldown = -0.1;
	}
	DestroyEffect(pActiveAbEffectList);
	pActiveAbEffectList = [];
	pActiveAbNumber = false;
}

void play_purchase_confirmation_sound() "Subroutine: Play Purchase Confirmation Sound"
{
	PlayEffect(EventPlayer(), PlayEffect.BuffExplosionSound, Color.White, gBuyMenuCamPos, 200);
}

void disable_player() "Subroutine: Disable Player"
{
	ForceThrottle(EventPlayer(), false, 0.1, false, 0.1, false, 0.1);
	SetPrimaryFireEnabled(EventPlayer(), false);
	SetSecondaryFireEnabled(EventPlayer(), false);
	SetAbility1Enabled(EventPlayer(), false);
	SetAbility2Enabled(EventPlayer(), false);
	SetMeleeEnabled(EventPlayer(), false);
	SetJumpEnabled(EventPlayer(), false);
	SetCrouchEnabled(EventPlayer(), false);
	DisallowButton(EventPlayer(), Button.Ultimate);
}

void enable_player() "Subroutine: Enable Player"
{
	StopForcingThrottle(EventPlayer());
	SetPrimaryFireEnabled(EventPlayer(), true);
	SetSecondaryFireEnabled(EventPlayer(), true);
	SetAbility1Enabled(EventPlayer(), true);
	SetAbility2Enabled(EventPlayer(), true);
	SetMeleeEnabled(EventPlayer(), true);
	SetJumpEnabled(EventPlayer(), true);
	SetCrouchEnabled(EventPlayer(), true);
	AllowButton(EventPlayer(), Button.Ultimate);
}

rule: "[Tutorial] Close HUD"
Event.OngoingPlayer
if (pTutActive)
if (IsButtonHeld(EventPlayer(), Button.Reload))
if (IsButtonHeld(EventPlayer(), Button.Crouch))
if (IsAlive(EventPlayer()))
{
	Wait(0.25, WaitBehavior.IgnoreCondition);
	pTutActive = false;
	SmallMessage(EventPlayer(), <"press <0> + <1> to toggle hero changes", InputBindingString(Button.Crouch), InputBindingString(Button.Reload)>);
}

rule: "[Tutorial] Open HUD"
Event.OngoingPlayer
if (!pTutActive)
if (IsButtonHeld(EventPlayer(), Button.Reload))
if (IsButtonHeld(EventPlayer(), Button.Crouch))
if (IsAlive(EventPlayer()))
{
	Wait(0.25, WaitBehavior.IgnoreCondition);
	pTutActive = true;
}

rule: "Team 1: Player Damage Automater (+-)"
Event.OngoingPlayer
Team.Team1
if (pDamageDealt[true] != pDamageDealt[false])
{
	pDamageDealt[true] = pDamageDealt[false];
	SetDamageDealt(EventPlayer(), pDamageDealt[true]);
}

rule: "Team 1: Player HP Automater (+-)"
Event.OngoingPlayer
Team.Team1
if (pHealthPercent[true] != pHealthPercent[false])
{
	pHealthPercent[true] = pHealthPercent[false];
	SetMaxHealth(EventPlayer(), pHealthPercent[true]);
}

rule: "Team 1: Player Resistance Automater (+-)"
Event.OngoingPlayer
Team.Team1
if (pDamageReceived[true] != pDamageReceived[false])
{
	pDamageReceived[true] = pDamageReceived[false];
	SetDamageReceived(EventPlayer(), pDamageReceived[true]);
}

rule: "Team 1: Player Move Speed Automater (+-)"
Event.OngoingPlayer
Team.Team1
if (pMoveSpeed[true] != pMoveSpeed[false])
{
	pMoveSpeed[true] = pMoveSpeed[false];
	SetMoveSpeed(EventPlayer(), pMoveSpeed[true]);
}

rule: "Team 1: Player Healing Automater (+-)"
Event.OngoingPlayer
Team.Team1
if (pHealingDealtPercent[true] != pHealingDealtPercent[false])
{
	pHealingDealtPercent[true] = pHealingDealtPercent[false];
	SetHealingDealt(EventPlayer(), pHealingDealtPercent[true]);
}

rule: "Team 1: Protect from One-shots if health is over 50%"
Event.OngoingPlayer
Team.Team1
if (NormalizedHealth(EventPlayer()) >= 0.5)
{
	SetStatus(EventPlayer(), null, Status.Unkillable, 9999);
	WaitUntil(NormalizedHealth(EventPlayer()) < 0.5, 99999);
	Wait(0.4, WaitBehavior.RestartWhenTrue);
	LoopIfConditionIsTrue();
	ClearStatus(EventPlayer(), Status.Unkillable);
}

rule: "Team 1 Button: Interact, Open / Leave Buy Menu"
Event.OngoingPlayer
Team.Team1
if (IsButtonHeld(EventPlayer(), Button.Interact))
{
	if (pInBuyMenu)
	{
		leave_buy_menu();
	}
	else if (DistanceBetween(EventPlayer(), gAbilityShopPos) <= 2)
	{
		open_buy_menu();
	}
	else if (pCanUseDropInBuyMenu || MatchTime())
	{
		Wait(0.4, WaitBehavior.AbortWhenFalse);
		open_buy_menu();
	}
	Wait(0.05, WaitBehavior.IgnoreCondition);
}

rule: "Team 1: Leave Buy Menu when downed, health low, stunned or tased"
Event.OngoingPlayer
Team.Team1
if (pInBuyMenu)
if (pDownedStartT || NormalizedHealth(EventPlayer()) < 0.5 || HasStatus(EventPlayer(), Status.Stunned) || pTasedEndT >= TotalTimeElapsed())
{
	leave_buy_menu();
	AbortIf(NormalizedHealth(EventPlayer()) > 0.4);
	SetPlayerHealth(EventPlayer(), 0.4 * MaxHealth(EventPlayer()));
}

rule: "Team 1: Toggle Show active Ability"
Event.OngoingPlayer
Team.Team1
if (pInBuyMenu)
if (IsButtonHeld(EventPlayer(), Button.Melee))
{
	AbortIf(pInBuyMenu + 0.1 >= TotalTimeElapsed());
	pIsShowingActiveAbilities = !pIsShowingActiveAbilities;
}

rule: "Team 1: Buy Ability"
Event.OngoingPlayer
Team.Team1
if (pInBuyMenu)
if (IsButtonHeld(EventPlayer(), Button.PrimaryFire))
{
	AbortIf(pInBuyMenu + 0.1 >= TotalTimeElapsed() || AbsoluteValue(HorizontalFacingAngleOf(EventPlayer())) >= 135 || AbsoluteValue(VerticalFacingAngleOf(EventPlayer()) + 11.25) >= 45 || pTasedEndT >= TotalTimeElapsed());
	# Grid coordinates of selected panel
	gTemp1 = [RoundToInteger((HorizontalFacingAngleOf(EventPlayer()) + 135) / 45, Rounding.Down), RoundToInteger((VerticalFacingAngleOf(EventPlayer()) + 56.25) / 22.5, Rounding.Down)];
	if (gTemp1[1] == 0)
	{
		if (gTemp1[0] <= 1)
		{
			leave_buy_menu();
		}
		else if (gTemp1[0] <= 3)
		{
			pIsShowingActiveAbilities = !pIsShowingActiveAbilities;
		}
		else
		{
			if (pMoneySpentAmount)
			{
				remove_active_ability();
				pMoneySpentAmount = false;
				pAbHeadhunter = false;
				pAbQuickFix = false;
				pAbCharged = false;
				pAbHeavyImpact = false;
				pAbSecondWind = false;
				pAbTriage = false;
				if (pAbResilience)
				{
					pAbResilience = false;
					pDamageReceived += 20;
				}
				SetKnockbackDealt(EventPlayer(), 100);
				SetKnockbackReceived(EventPlayer(), 100);
				pAbAntigens = false;
				StopHealingModification(pHealMod[1]);
				StopHealOverTime(pHealMod[2]);
				StopDamageModification(pDamageMod[11]);
				StopDamageModification(pDamageMod[12]);
				pAbHaste = false;
				pAbPriority = false;
				pHealthPercent -= pAbHealthBonus;
				pAbHealthBonus = false;
				pDamageDealt -= pAbDamageBonus;
				pAbDamageBonus = false;
				pHealingDealtPercent -= pAbHealingBonus;
				pAbHealingBonus = false;
				pPerkBulletStorm = false;
				pPerkDieHard = false;
				pPerkBrassKnuckles = false;
				pPerkVampiric = false;
				pPerkCrashNDash = false;
				pPerkGoldenHour = false;
				pPerkSuperCharge = false;
				if (pPerkNemesis)
				{
					DestroyEffect(pNemesisBeamEffect);
					pPerkNemesis = false;
				}
				if (pPerkSpecialOperator)
				{
					RemoveHealthPoolFromPlayer(pHpPool[2]);
					pPerkSpecialOperator = false;
				}
				pPerkSharpShooter = false;
				StopDamageModification(pDamageMod[10]);
				pTalent1 = false;
				pTalent2 = false;
				if (pPerkMysterySwap)
				{
					pHealthPercent -= 20;
					pDamageDealt -= 20;
					pHealingDealtPercent -= 20;
					StopForcingHero(EventPlayer());
					pPerkMysterySwap = false;
				}
				if (pPerkShockProof)
				{
					EnableMovementCollisionWithPlayers(EventPlayer());
					pMoveSpeed -= 15;
					MinWait();
					pPerkShockProof = false;
				}
				SmallMessage(EventPlayer(), "Money Refunded");
				update_ab_string_and_play_sound();
				Abort();
			}
		}
	}
	else
	{
		if (gTemp1[0] == 0)
		{
			if (gTemp1[1] >= 2)
			{
				gTemp2 = gCurrentPerks[gTemp1[1] >= 3];
				if (gTemp2 == 0)
				{
					if (!pPerkMysterySwap)
					{
						gTemp2 = 500;
						check_if_enough_money();
						if (gTemp2)
						{
							pHealthPercent += 20;
							pDamageDealt += 20;
							pHealingDealtPercent += 20;
							pPerkMysterySwap = TotalTimeElapsed() + 90;
							update_ab_string_and_play_sound();
						}
					}
				}
				else if (gTemp2 == 1)
				{
					if (!pPerkBulletStorm)
					{
						gTemp2 = 1000;
						check_if_enough_money();
						if (gTemp2)
						{
							pPerkBulletStorm = true;
							update_ab_string_and_play_sound();
						}
					}
				}
				else if (gTemp2 == 2)
				{
					if (!pPerkDieHard)
					{
						gTemp2 = 700;
						check_if_enough_money();
						if (gTemp2)
						{
							pPerkDieHard = true;
							update_ab_string_and_play_sound();
						}
					}
				}
				else if (gTemp2 == 3)
				{
					if (!pPerkBrassKnuckles)
					{
						gTemp2 = 700;
						check_if_enough_money();
						if (gTemp2)
						{
							pPerkBrassKnuckles = true;
							update_ab_string_and_play_sound();
						}
					}
				}
				else if (gTemp2 == 4)
				{
					if (!pPerkVampiric)
					{
						gTemp2 = 1000;
						check_if_enough_money();
						if (gTemp2)
						{
							pPerkVampiric = true;
							update_ab_string_and_play_sound();
						}
					}
				}
				else if (gTemp2 == 5)
				{
					if (!pPerkCrashNDash)
					{
						gTemp2 = 700;
						check_if_enough_money();
						if (gTemp2)
						{
							pPerkCrashNDash = true;
							update_ab_string_and_play_sound();
						}
					}
				}
				else if (gTemp2 == 6)
				{
					if (!pPerkGoldenHour)
					{
						gTemp2 = 1000;
						check_if_enough_money();
						if (gTemp2)
						{
							pPerkGoldenHour = true;
							update_ab_string_and_play_sound();
						}
					}
				}
				else if (gTemp2 == 7)
				{
					if (!pPerkSuperCharge)
					{
						gTemp2 = 700;
						check_if_enough_money();
						if (gTemp2)
						{
							pPerkSuperCharge = true;
							update_ab_string_and_play_sound();
						}
					}
				}
				else if (gTemp2 == 8)
				{
					if (!pPerkNemesis)
					{
						gTemp2 = 800;
						check_if_enough_money();
						if (gTemp2)
						{
							pPerkNemesis = true;
							CreateBeamEffect(pPerkNemesisKiller ? AllPlayers() : [], BeamType.BadBeam, PositionOf(EventPlayer()), pPerkNemesisKiller, Color.Black, EffectRev.VisibleToPositionAndRadius);
							pNemesisBeamEffect = LastCreatedEntity();
							update_ab_string_and_play_sound();
						}
					}
				}
				else if (gTemp2 == 9)
				{
					if (!pPerkSpecialOperator)
					{
						gTemp2 = 600;
						check_if_enough_money();
						if (gTemp2)
						{
							AddHealthPoolToPlayer(EventPlayer(), HealthType.Armor, 50, true, true);
							pHpPool[2] = LastCreatedHealthPool();
							pPerkSpecialOperator = true;
							update_ab_string_and_play_sound();
						}
					}
				}
				else if (gTemp2 == 10)
				{
					if (!pPerkSharpShooter)
					{
						gTemp2 = 900;
						check_if_enough_money();
						if (gTemp2)
						{
							pPerkSharpShooter = true;
							StartDamageModification(FilteredArray(AllPlayers(Team.Team2), DistanceBetween(EventPlayer(), ArrayElement()) > 20), EventPlayer(), 150, DamageModificationRev.ReceiversDamagersAndDamagePercent);
							pDamageMod[10] = LastDamageModificationID();
							update_ab_string_and_play_sound();
						}
					}
				}
				else if (gTemp2 == 11)
				{
					if (!pPerkShockProof)
					{
						gTemp2 = 700;
						check_if_enough_money();
						if (gTemp2)
						{
							DisableMovementCollisionWithPlayers(EventPlayer());
							pMoveSpeed += 15;
							pPerkShockProof = true;
							update_ab_string_and_play_sound();
						}
					}
				}
				else if (gTemp2 == 12)
				{
					if (!pTalent1)
					{
						gTemp2 = 1600;
						check_if_enough_money();
						if (gTemp2)
						{
							pTalent1 = true;
							update_ab_string_and_play_sound();
						}
					}
				}
				else if (gTemp2 == 13)
				{
					if (!pTalent2)
					{
						gTemp2 = 1600;
						check_if_enough_money();
						if (gTemp2)
						{
							pTalent2 = true;
							update_ab_string_and_play_sound();
						}
					}
				}
			}
		}
		else if (gTemp1[0] == 1)
		{
			if (pIsShowingActiveAbilities)
			{
				if (gTemp1[1] == 1)
				{
					gTemp1 = 4;
					buy_active_ability();
				}
				else if (gTemp1[1] == 2)
				{
					gTemp1 = 8;
					buy_active_ability();
				}
			}
			else
			{
				gTemp2 = 500;
				check_if_enough_money();
				if (gTemp2)
				{
					if (gTemp1[1] == 1)
					{
						pAbHealthBonus += 5;
						pHealthPercent += 5;
					}
					else if (gTemp1[1] == 2)
					{
						pAbDamageBonus += 5;
						pDamageDealt += 5;
						SetDamageDealt(EventPlayer(), pDamageDealt[0]);
					}
					else
					{
						pAbHealingBonus += 5;
						pHealingDealtPercent += 5;
					}
					update_ab_string_and_play_sound();
				}
			}
		}
		else if (gTemp1[0] == 2)
		{
			if (pIsShowingActiveAbilities)
			{
				if (gTemp1[1] == 1)
				{
					gTemp1 = 3;
					buy_active_ability();
				}
				else if (gTemp1[1] == 2)
				{
					gTemp1 = 7;
					buy_active_ability();
				}
			}
			else
			{
				if (gTemp1[1] == 1)
				{
					if (pAbSecondWind < 2)
					{
						gTemp2 = 1000;
						check_if_enough_money();
						if (gTemp2)
						{
							pAbSecondWind = pAbSecondWind ? 2 : 1;
							update_ab_string_and_play_sound();
						}
					}
				}
				else if (gTemp1[1] == 2)
				{
					if (pAbTriage < 2)
					{
						gTemp2 = 700;
						check_if_enough_money();
						if (gTemp2)
						{
							pAbTriage = pAbTriage ? 2 : 1;
							update_ab_string_and_play_sound();
						}
					}
				}
				else
				{
					if (pAbResilience < 2)
					{
						gTemp2 = 800;
						check_if_enough_money();
						if (gTemp2)
						{
							pAbResilience = pAbResilience ? 2 : 1;
							pDamageReceived -= 20;
							SetKnockbackDealt(EventPlayer(), 100 + 30 * pAbResilience);
							SetKnockbackReceived(EventPlayer(), 100 - 30 * pAbResilience);
							update_ab_string_and_play_sound();
						}
					}
				}
			}
		}
		else if (gTemp1[0] == 3)
		{
			if (pIsShowingActiveAbilities)
			{
				if (gTemp1[1] == 1)
				{
					gTemp1 = 2;
					buy_active_ability();
				}
				else if (gTemp1[1] == 2)
				{
					gTemp1 = 6;
					buy_active_ability();
				}
			}
			else
			{
				if (gTemp1[1] == 1)
				{
					if (pAbCharged < 2)
					{
						gTemp2 = 700;
						check_if_enough_money();
						if (gTemp2)
						{
							pAbCharged = pAbCharged ? 2 : 1;
							update_ab_string_and_play_sound();
						}
					}
				}
				else if (gTemp1[1] == 2)
				{
					if (pAbHaste < 2)
					{
						gTemp2 = 800;
						check_if_enough_money();
						if (gTemp2)
						{
							pAbHaste = pAbHaste ? 2 : 1;
							update_ab_string_and_play_sound();
						}
					}
				}
				else
				{
					if (pAbHeavyImpact < 2)
					{
						gTemp2 = 1000;
						check_if_enough_money();
						if (gTemp2)
						{
							pAbHeavyImpact = pAbHeavyImpact ? 2 : 1;
							update_ab_string_and_play_sound();
						}
					}
				}
			}
		}
		else if (gTemp1[0] == 4)
		{
			if (pIsShowingActiveAbilities)
			{
				if (gTemp1[1] == 1)
				{
					gTemp1 = 1;
					buy_active_ability();
				}
				else if (gTemp1[1] == 2)
				{
					gTemp1 = 5;
					buy_active_ability();
				}
			}
			else
			{
				if (gTemp1[1] == 1)
				{
					if (pAbHeadhunter < 2)
					{
						gTemp2 = 800;
						check_if_enough_money();
						if (gTemp2)
						{
							pAbHeadhunter = pAbHeadhunter ? 2 : 1;
							update_ab_string_and_play_sound();
						}
					}
				}
				else if (gTemp1[1] == 2)
				{
					if (pAbAntigens < 2)
					{
						gTemp2 = 600;
						check_if_enough_money();
						if (gTemp2)
						{
							StopHealingModification(pHealMod[1]);
							StopHealOverTime(pHealMod[2]);
							pAbAntigens = pAbAntigens ? 2 : 1;
							StartHealingModification(EventPlayer(), AllPlayers(), 100 + 20 * pAbAntigens, HealingModificationRev.ReceiversDamagersAndDamagePercent);
							pHealMod[1] = LastHealingModificationID();
							StartHealOverTime(EventPlayer(), null, 9999, MaxHealth(EventPlayer()) * 0.01 * pAbAntigens);
							pHealMod[2] = LastHealOverTime();
							update_ab_string_and_play_sound();
						}
					}
				}
				else
				{
					if (pAbQuickFix < 2)
					{
						gTemp2 = 700;
						check_if_enough_money();
						if (gTemp2)
						{
							pAbQuickFix = pAbQuickFix ? 2 : 1;
							update_ab_string_and_play_sound();
						}
					}
				}
			}
		}
		else
		{
			if (!pAbPriority)
			{
				gTemp2 = 1200;
				check_if_enough_money();
				if (!gTemp2)
				{
					Wait(0.1, WaitBehavior.IgnoreCondition);
					Abort();
				}
			}
			else if (gTemp1[1] == pAbPriority)
			{
				Wait(0.1, WaitBehavior.IgnoreCondition);
				Abort();
			}
			else
			{
				SmallMessage(EventPlayer(), "Swapped Priority");
			}
			pAbPriority = gTemp1[1];
			update_ab_string_and_play_sound();
		}
	}
	Wait(0.1, WaitBehavior.IgnoreCondition);
}

rule: "Team 1 (Spawn): Player Init, Create Effects, Set Is Combatant"
Event.OngoingPlayer
Team.Team1
if (HasSpawned(EventPlayer()))
{
	# Fail-Safe if player somehow despawned (Like Echo duplicating D.Va)
	AbortIf(pIsCombatant);
	SmallMessage(EventPlayer(), "*******​ ​***********​ PvE: Talents​ | 3.4.6 ​***​ LemonAid");
	# Triage: Players to Players Healing Increase
	StartHealingModification(FilteredArray(gCombatants, NormalizedHealth(ArrayElement()) <= 0.5), EventPlayer(), 100 + 25 * pAbTriage, HealingModificationRev.ReceiversDamagersAndDamagePercent);
	pIsCombatant = true;
	pSpectatedPlayer = EventPlayer();
	pAbBoughtAbilitiesString = "";
	pHealthPercent = 100;
	pHealingDealtPercent = 100;
	SetHealingReceived(EventPlayer(), 85 + 2.5 * gUpgradeCount);
	update_combatants();
	CreateEffect(pDownedStartT ? AllPlayers() : [], Effect.Ring, Color.Yellow, EventPlayer(), 3, EffectRev.VisibleTo);
	CreateIcon(pDownedStartT ? RemoveFromArray(AllPlayers(), EventPlayer()) : [], EventPlayer(), Icon.Skull, IconRev.VisibleTo, Color.Yellow, true);
	# Workaround: Normalized Health sometimes doesn't reevaluate, so force with TTE
	CreateHudText(AllPlayers(Team.Team1), <"<0><1>", HeroIconString(HeroOf(EventPlayer())), pDownedStartT && pReviveTimer ? gProgressBarStrings[RoundToInteger(pReviveTimer / 10, Rounding.Down)] : "">, <"<0><1><2>", EventPlayer(), pAbPriority ? ["(A)", "(B)", "(C)"][pAbPriority - 1] : "", pInBuyMenu ? "(In Shop)" : "">, <"<0><1>", pDownedStartT ? pReviveTimer ? "Being Revived" : "Downed" : pIsChangedHeroes ? "Changing Heroes" : <"<0> HP", RoundToInteger(Health(EventPlayer()), Rounding.Up)>, <", <0>$", RoundToInteger(gMoneyMult * gMoneyAmount - pMoneySpentAmount, Rounding.Down)>>, Location.Left, LocalPlayer() == EventPlayer() ? -1 : SlotOf(EventPlayer()), pDownedStartT ? Color.Red : pIsChangedHeroes || NormalizedHealth(EventPlayer()) >= 0.5 ? LocalPlayer() == EventPlayer() ? Color.Green : Color.SkyBlue : Color.Orange, pDownedStartT ? Color.Red : pIsChangedHeroes || NormalizedHealth(EventPlayer()) >= 0.5 ? LocalPlayer() == EventPlayer() ? Color.Green : Color.SkyBlue : Color.Orange, pDownedStartT ? Color.Red : pIsChangedHeroes || NormalizedHealth(EventPlayer()) >= 0.5 ? LocalPlayer() == EventPlayer() ? Color.Green : Color.SkyBlue : Color.Orange, HudTextRev.VisibleToSortOrderStringAndColor, Spectators.DefaultVisibility);
	# Stats
	pDamageReceived = 100;
	pDamageDealt = 100;
	pMoveSpeed = 100;
	# Ability lists
	CreateHudText(pIsCombatant ? EventPlayer() : [], null, pSpectatedPlayer.pAbBoughtAbilitiesString, null, Location.Left, 10, null, Color.Green, null, HudTextRev.VisibleToAndString, Spectators.DefaultVisibility);
	CreateHudText(pSpectatedPlayer.pTalent1 ? EventPlayer() : [], "", pSpectatedPlayer.pTalentText[2], <"<0>\n━━━━", pSpectatedPlayer.pTalentText[1]>, Location.Left, 11, Color.Blue, Color.White, Color.SkyBlue, HudTextRev.VisibleToAndString, Spectators.DefaultVisibility);
	CreateHudText(pSpectatedPlayer.pTalent2 ? EventPlayer() : [], "", pSpectatedPlayer.pTalentText[4], <"<0>\n━━━━", pSpectatedPlayer.pTalentText[3]>, Location.Left, 12, Color.Blue, Color.White, Color.SkyBlue, HudTextRev.VisibleToAndString, Spectators.DefaultVisibility);
	CreateHudText(pSpectatedPlayer.pActiveAbNumber ? EventPlayer() : [], AbilityIconString([Hero.Ana, Hero.Sombra, Hero.Soldier76, Hero.Reaper, Hero.Cassidy, Hero.Baptiste, Hero.Sigma, Hero.Sombra][pSpectatedPlayer.pActiveAbNumber - 1], [Button.Ultimate, Button.Ability1, Button.Ability1, Button.Ability1, Button.Ability2, Button.Ability1, Button.Ultimate, Button.SecondaryFire][pSpectatedPlayer.pActiveAbNumber - 1]), <"Hold or double tap <0>", InputBindingString(Button.Melee)>, <"<0>: <1>", ["Stim Infusion", "Cloak", "Feint", "Frenzy", "Smoke Bomb", "Resurgence", "Tear Gas", "Chain Hack"][pSpectatedPlayer.pActiveAbNumber - 1], pSpectatedPlayer.pActiveAbCooldown ? RoundToInteger(pSpectatedPlayer.pActiveAbCooldown, Rounding.Up) : "Ready">, Location.Left, 13, pSpectatedPlayer.pActiveAbCooldown < 0 ? Color.Green : HasStatus(pSpectatedPlayer, Status.Hacked) || HasStatus(pSpectatedPlayer, Status.Stunned) ? Color.Red : pSpectatedPlayer.pActiveAbCooldown ? Color.Gray : Color.Green, Color.Orange, pSpectatedPlayer.pActiveAbCooldown < 0 ? Color.Green : HasStatus(pSpectatedPlayer, Status.Hacked) || HasStatus(pSpectatedPlayer, Status.Stunned) ? Color.Red : pSpectatedPlayer.pActiveAbCooldown ? Color.Gray : Color.Green, HudTextRev.VisibleToStringAndColor, Spectators.DefaultVisibility);
	CreateEffect(pSmokedScreen && !pPerkSpecialOperator ? EventPlayer() : [], Effect.Sphere, Color.White, EventPlayer(), 5, EffectRev.VisibleToPositionAndRadius);
	CreateEffect(HasStatus(EventPlayer(), Status.Invincible) ? AllPlayers() : [], Effect.BaptisteImmortalityFieldProtectedEffect, Team.Team2, EventPlayer(), 1, EffectRev.VisibleToPositionAndRadius);
	if (gWaveNumber > 0)
	{
		StartForcingPlayerOutlines(FilteredArray(AllPlayers(Team.Team2), ArrayElement().pIsLivingBoss), EventPlayer(), true, Color.Yellow, OutlineType.Always);
		pCanUseDropInBuyMenu = true;
		WaitUntil(pInBuyMenu, 15);
		pCanUseDropInBuyMenu = false;
		if (pInBuyMenu)
		{
			pActiveAbIsCloaked = true;
			SetStatus(EventPlayer(), null, Status.PhasedOut, 30);
			WaitUntil(!pInBuyMenu, 30);
			pActiveAbIsCloaked = false;
			ClearStatus(EventPlayer(), Status.PhasedOut);
		}
	}
	else
	{
		Teleport(EventPlayer(), gPlayerSpawnPos);
		Wait(0.2, WaitBehavior.IgnoreCondition);
		SetFacing(EventPlayer(), gPlayerSpawnFacing, Relative.ToWorld);
	}
}

rule: "Team 1: Add Health Pool"
Event.OngoingPlayer
Team.Team1
if (pIsCombatant)
if (gUpgradeCount > 0)
{
	AddHealthPoolToPlayer(EventPlayer(), HealthType.Health, pHealthPercent * 0.25 * gUpgradeCount, true, true);
}

rule: "Team 1 Button: Hold Reload, Change Hero, Set Last Position (1), Last Eye Position (2), Last Facing (3)"
Event.OngoingPlayer
Team.Team1
if (IsButtonHeld(EventPlayer(), Button.Reload))
{
	Wait(0.4, WaitBehavior.AbortWhenFalse);
	AbortIf(gObjectivePhaseNumber > 0 || pDownedStartT || pInBuyMenu);
	if (pPerkMysterySwap)
	{
		SmallMessage(EventPlayer(), "Mystery Swap prevents you from changing heroes");
		Abort();
	}
	pIsChangedHeroes = true;
	pAbVar1 = PositionOf(EventPlayer());
	pAbVar2 = EyePosition(EventPlayer());
	pAbVar3 = FacingDirectionOf(EventPlayer());
	PlayEffect(AllPlayers(), PlayEffect.GoodPickupEffect, Color.Yellow, pAbVar1, 1);
	StartCamera(EventPlayer(), RayCastHitPosition(pAbVar2, pAbVar2 - 8.25 * DirectionFromAngles(HorizontalAngleFromDirection(pAbVar3), 20), null, null, false) + 0.25 * DirectionFromAngles(HorizontalAngleFromDirection(pAbVar3), 20), pAbVar2, 0);
	ClearStatus(EventPlayer(), Status.Unkillable);
	Kill(EventPlayer(), null);
	# Lower values might cause the player to fall through the map when respawning
	Teleport(EventPlayer(), 100 * Down());
	Wait(0.1, WaitBehavior.IgnoreCondition);
	pIsInvisible = 2;
	WaitUntil(IsAlive(EventPlayer()), 99999);
	StopCamera(EventPlayer());
	Teleport(EventPlayer(), pAbVar1);
	SetFacing(EventPlayer(), pAbVar3, Relative.ToWorld);
	pIsChangedHeroes = false;
	pIsInvisible = false;
	Wait(0.5, WaitBehavior.IgnoreCondition);
	update_ab_string_and_play_sound();
}

rule: "Team 1: Took Damage, Set Last Damage Taken"
Event.OnDamageTaken
Team.Team1
{
	pLastDamageTakenT = TotalTimeElapsed();
}

rule: "Team 1 (Death): Start Camera, Play Sounds, Set is Downed, Revive Timer, Knocked down, Phased out, Death Cam Target"
Event.OnDeath
Team.Team1
if (!pIsChangedHeroes)
{
	if (!pDownedStartT)
	{
		DisableMessages(EventPlayer());
		SmallMessage(AllPlayers(), <"<0> was downed!", EventPlayer()>);
		pDeathCamTarget = EyePosition(EventPlayer()) + 1000 * DirectionFromAngles(HorizontalFacingAngleOf(EventPlayer()), 0);
		StartCamera(EventPlayer(), RayCastHitPosition(EyePosition(pSpectatedPlayer), EyePosition(pSpectatedPlayer) - (pDeathCamTarget ? 6.25 * DirectionTowards(EyePosition(pSpectatedPlayer), pDeathCamTarget) : 8.25 * DirectionFromAngles(HorizontalFacingAngleOf(pSpectatedPlayer), 20)), null, null, false) + 0.25 * (pDeathCamTarget ? DirectionTowards(EyePosition(pSpectatedPlayer), pDeathCamTarget) : DirectionFromAngles(HorizontalFacingAngleOf(pSpectatedPlayer), 20)), EyePosition(pSpectatedPlayer), pDeathCamTarget ? 10 : 20);
		for (gIterator = 0; gCombatantsCount; 1)
		{
			PlayEffect(gCombatants[gIterator], PlayEffect.RingExplosionSound, Color.White, gCombatants[gIterator], 200);
			PlayEffect(gCombatants[gIterator], PlayEffect.RingExplosionSound, Color.White, gCombatants[gIterator], 200);
		}
		pDownedStartT = TotalTimeElapsed();
		pReviveTimer = false;
		if (pPerkNemesis && Attacker().pIsAlive && TeamOf(Attacker()) == Team.Team2 && !Attacker().pIvIsPortal && SlotOf(Attacker()) != 1)
		{
			pPerkNemesisKiller = Attacker();
		}
		else
		{
			pPerkNemesisKiller = null;
		}
		disable_player();
	}
	if (EventWasEnvironment())
	{
		gTemp1 = NearestWalkablePosition(EventPlayer());
		nwp_teleport();
	}
	Resurrect(EventPlayer());
	ClearStatus(EventPlayer(), Status.PhasedOut);
	SetStatus(EventPlayer(), null, Status.Invincible, 9999);
	// SetStatus(EventPlayer(), null, Status.KnockedDown, 9999);
	Wait(0.05, WaitBehavior.RestartWhenTrue);
	SetPlayerHealth(EventPlayer(), 1);
	SetStatus(EventPlayer(), null, Status.PhasedOut, 9999);
	if (Attacker() != EventPlayer())
	{
		pDeathCamTarget = Attacker();
		Wait(5, WaitBehavior.RestartWhenTrue);
	}
	pDeathCamTarget = null;
}

rule: "Team 1: Player downed fallback"
Event.OngoingPlayer
Team.Team1
if (pDownedStartT)
if (!HasStatus(EventPlayer(), Status.Stunned))
{
	Wait(0.25, WaitBehavior.AbortWhenFalse);
	AbortIfConditionIsFalse();
	StartScalingPlayer(EventPlayer(), 0.5, false);
	disable_player();
	while (pDownedStartT && !HasStatus(EventPlayer(), Status.Hacked))
	{
		ClearStatus(EventPlayer(), Status.PhasedOut);
		CancelPrimaryAction(EventPlayer());
		SetStatus(EventPlayer(), null, Status.Hacked, 9999);
		Wait(0.25, WaitBehavior.IgnoreCondition);
	}
	if (pDownedStartT)
	{
		SetStatus(EventPlayer(), null, Status.PhasedOut, 9999);
	}
	LoopIfConditionIsTrue();
}

rule: "Team 1: Select Next Spectated Player"
Event.OngoingPlayer
Team.Team1
if (pDownedStartT)
if (IsButtonHeld(EventPlayer(), Button.Jump))
{
	AbortIf(pDownedStartT + 0.5 >= TotalTimeElapsed());
	pDeathCamTarget = null;
	if (pPerkNemesisKiller)
	{
		if (pSpectatedPlayer == EventPlayer())
		{
			pSpectatedPlayer = pPerkNemesisKiller;
		}
		else
		{
			pSpectatedPlayer = EventPlayer();
		}
	}
	else
	{
		pSpectatedPlayer = gCombatants[(IndexOfArrayValue(gCombatants, pSpectatedPlayer) + 1) % gCombatantsCount];
	}
	Wait(0.25, WaitBehavior.IgnoreCondition);
}

rule: "Team 1: Spectated Player does not exist anymore"
Event.OngoingPlayer
Team.Team1
if (!EntityExists(pSpectatedPlayer))
{
	pSpectatedPlayer = EventPlayer();
}

rule: "Team 1: Revive, Check Player in Radius, Unset Is Downed"
Event.OngoingPlayer
Team.Team1
if (pDownedStartT)
if (pDownedStartT + 1 < TotalTimeElapsed())
{
	pRevivers = FilteredArray(gCombatants, !ArrayElement().pDownedStartT && !(ArrayElement().pIsInvisible % 3) && DistanceBetween(EventPlayer(), Vector(XOf(PositionOf(ArrayElement())), YOf(PositionOf(EventPlayer())), ZOf(PositionOf(ArrayElement())))) <= 3 && AbsoluteValue(YOf(PositionOf(EventPlayer())) - YOf(PositionOf(ArrayElement()))) <= 3 && (HeroOf(ArrayElement()) == Hero.Mei && IsUsingAbility1(ArrayElement()) || IsInLineOfSight(EventPlayer(), ArrayElement(), BarrierLOS.NoBarriersBlock)));
	if (CountOf(pRevivers))
	{
		pIsReviveSlow = IsTrueForAll(pRevivers, ArrayElement().pActiveAbIsCloaked || HasStatus(ArrayElement(), Status.Invincible) || HasStatus(ArrayElement(), Status.PhasedOut));
		pReviveTimer += (gIsHardModeEnabled || gIsApocalyptic ? 0.667 : 1) * (pPerkGoldenHour ? 2 : 1) * (pIsReviveSlow ? 2.5 : 5);
		if (pReviveTimer >= 100)
		{
			SmallMessage(AllPlayers(), <"<0> has been revived!", EventPlayer()>);
			pDownedStartT = false;
		}
	}
	else
	{
		pReviveTimer = false;
	}
	Wait(0.2, WaitBehavior.IgnoreCondition);
	LoopIfConditionIsTrue();
}

rule: "Team 1: Teleport if Player died on Jumppad"
Event.OngoingPlayer
Team.Team1
if (pDownedStartT)
if (pDownedStartT + 5 < TotalTimeElapsed())
if (pIsFlying)
{
	gTemp1 = NearestWalkablePosition(PositionOf(EventPlayer()) + 5 * DirectionFromAngles(RandomInteger(-179, 180), false));
	nwp_teleport();
}

rule: "Team 1: Player gets up"
Event.OngoingPlayer
Team.Team1
if (!pDownedStartT)
{
	AbortIf(!pIsCombatant);
	EnableMessages(EventPlayer());
	StopCamera(EventPlayer());
	enable_player();
	PlayEffect(AllPlayers(), PlayEffect.BuffImpactSound, Color.White, EventPlayer(), 200);
	SetPlayerHealth(EventPlayer(), 100000);
	pSpectatedPlayer = EventPlayer();
	pRevivers = [];
	pPerkNemesisKiller = null;
	ClearStatus(EventPlayer(), Status.Hacked);
	ClearStatus(EventPlayer(), Status.Invincible);
	enable_player();
	StopScalingPlayer(EventPlayer());
	Wait(2, WaitBehavior.AbortWhenFalse);
	AbortIfConditionIsFalse();
	ClearStatus(EventPlayer(), Status.PhasedOut);
}

rule: "Team 1: Heal after few sec"
Event.OngoingPlayer
Team.Team1
if (pLastDamageTakenT + (pPerkDieHard ? 0.5 : 1) * (gMutDeepWounds ? 5 : 2.5) < TotalTimeElapsed())
if (NormalizedHealth(EventPlayer()) != 1)
if (Health(EventPlayer()))
{
	Heal(EventPlayer(), null, MaxHealth(EventPlayer()) * 0.333);
	PlayEffect(EventPlayer(), PlayEffect.BuffExplosionSound, Color.White, EventPlayer(), 50);
	while (true)
	{
		Wait(0.2, WaitBehavior.AbortWhenFalse);
		AbortIfConditionIsFalse();
		Heal(EventPlayer(), null, 40);
	}
}

rule: "Team 1: Set / Unset Is Flying"
Event.OngoingPlayer
Team.Team1
if (!IsOnGround(EventPlayer()))
{
	Wait(1.5, WaitBehavior.AbortWhenFalse);
	pIsFlying = true;
	WaitUntil(IsOnGround(EventPlayer()), 99999);
	pIsFlying = false;
}

rule: "Team 1: Calculate Eye Offset"
Event.OngoingPlayer
Team.Team1
if (pIsCombatant)
{
	if (HeroOf(EventPlayer()) == Hero.Mei && IsUsingAbility1(EventPlayer()))
	{
		pEyeOffset = 1.2 * Up();
	}
	else if (HasStatus(EventPlayer(), Status.KnockedDown) || HasStatus(EventPlayer(), Status.Asleep) || IsCommunicatingAnyEmote(EventPlayer()))
	{
		pEyeOffset = PositionOf(EventPlayer()) + 0.25 * Up() - EyePosition(EventPlayer());
	}
	else
	{
		pEyeOffset = gAimOffset;
	}
	if (pActiveAbIsSmoked)
	{
		pActiveAbIsSmoked = false;
		pEyeOffset += RandomReal(0.5, 2) * DirectionFromAngles(RandomInteger(-179, 180), RandomInteger(0, 45));
	}
	Wait(1, WaitBehavior.IgnoreCondition);
	LoopIfConditionIsTrue();
}

rule: "Team 1 Button: Hold or double tap Melee, Use active Ability"
Event.OngoingPlayer
Team.Team1
if (IsButtonHeld(EventPlayer(), Button.Melee))
{
	WaitUntil(!IsButtonHeld(EventPlayer(), Button.Melee), 0.4);
	if (!IsButtonHeld(EventPlayer(), Button.Melee))
	{
		WaitUntil(IsButtonHeld(EventPlayer(), Button.Melee), 0.3);
		AbortIf(!IsButtonHeld(EventPlayer(), Button.Melee));
	}
	AbortIf(IsDead(EventPlayer()) || pDownedStartT || HasStatus(EventPlayer(), Status.Hacked) || HasStatus(EventPlayer(), Status.Stunned) || !pActiveAbNumber || pInBuyMenu);
	PlayEffect(EventPlayer(), PlayEffect.DebuffImpactSound, Color.White, EventPlayer(), 200);
	if (pActiveAbNumber == 1)
	{
		pLastDamageTakenT = false;
		SetStatus(EventPlayer(), null, Status.Invincible, 0.1);
		pDamageDealt += 100;
		pHealingDealtPercent += 100;
		pMoveSpeed += 50;
		for (pActiveAbCooldown = -6; 0; 1)
		{
			Wait(1, WaitBehavior.IgnoreCondition);
		}
		pDamageDealt -= 100;
		pHealingDealtPercent -= 100;
		pMoveSpeed -= 50;
		pActiveAbCooldown = 30;
	}
	else if (pActiveAbNumber == 2)
	{
		pActiveAbIsCloaked = true;
		for (pActiveAbCooldown = -8; 0; 1)
		{
			Wait(1, WaitBehavior.IgnoreCondition);
		}
		pActiveAbIsCloaked = false;
		Damage(PlayersWithinRadius(EyePosition(EventPlayer()), 10, Team.Team2, RadiusLOS.Surfaces), EventPlayer(), 99);
		SetStatus(PlayersWithinRadius(EyePosition(EventPlayer()), 10, Team.Team2, RadiusLOS.Surfaces), EventPlayer(), Status.Frozen, 4);
		PlayEffect(AllPlayers(), PlayEffect.GoodExplosion, Color.Aqua, EyePosition(EventPlayer()), 10);
		PlayEffect(AllPlayers(), PlayEffect.ExplosionSound, Color.White, EventPlayer(), 200);
		pActiveAbCooldown = 20;
	}
	else if (pActiveAbNumber == 3)
	{
		pActiveAbCooldown = -1;
		gTemp1 = PlayersWithinRadius(EyePosition(EventPlayer()), 6, Team.Team2, RadiusLOS.Surfaces);
		Damage(gTemp1, EventPlayer(), 100);
		ApplyImpulse(EventPlayer(), ThrottleOf(EventPlayer()) != Vector(0, 0, 0) ? ThrottleOf(EventPlayer()) : Forward(), 25, Relative.ToPlayer, ContraryMotion.Cancel);
		PlayEffect(AllPlayers(), PlayEffect.BadExplosion, Color.Black, EyePosition(EventPlayer()), 6);
		PlayEffect(AllPlayers(), PlayEffect.ExplosionSound, Color.White, EventPlayer(), 200);
		SetGravity(EventPlayer(), 0);
		SetStatus(EventPlayer(), null, Status.PhasedOut, 0.7);
		Wait(0.6, WaitBehavior.IgnoreCondition);
		SetGravity(EventPlayer(), 100);
		gTemp1 = PlayersWithinRadius(EyePosition(EventPlayer()), 6, Team.Team2, RadiusLOS.Surfaces);
		Damage(gTemp1, EventPlayer(), 100);
		PlayEffect(AllPlayers(), PlayEffect.BadExplosion, Color.Black, EyePosition(EventPlayer()), 6);
		PlayEffect(AllPlayers(), PlayEffect.ExplosionSound, Color.White, EventPlayer(), 200);
		pActiveAbCooldown = 10;
		Wait(1, WaitBehavior.IgnoreCondition);
	}
	else if (pActiveAbNumber == 4)
	{
		pActiveAbIsFrenzied = true;
		SetStatus(EventPlayer(), null, Status.Invincible, 5);
		for (pActiveAbCooldown = -5; 0; 1)
		{
			pLastDamageTakenT = TotalTimeElapsed();
			Wait(1, WaitBehavior.IgnoreCondition);
		}
		pActiveAbIsFrenzied = false;
		pActiveAbCooldown = 30;
	}
	else if (pActiveAbNumber == 5)
	{
		pActiveAbVar = RayCastHitPosition(EyePosition(EventPlayer()), EyePosition(EventPlayer()) + 2 * Down(), null, null, false) + 2 * Up();
		for (pActiveAbCooldown = -10; 0; 0.5)
		{
			(<Player>FilteredArray(gCombatants, DistanceBetween(EyePosition(ArrayElement()), Vector(XOf(pActiveAbVar), YOf(EyePosition(ArrayElement())), ZOf(pActiveAbVar))) <= 10 && AbsoluteValue(YOf(EyePosition(ArrayElement())) - YOf(pActiveAbVar)) <= 5)).pActiveAbIsSmoked = true;
			Wait(0.5, WaitBehavior.IgnoreCondition);
		}
		pActiveAbCooldown = 20;
	}
	else if (pActiveAbNumber == 6)
	{
		for (pActiveAbCooldown = -5; 0; 0.25)
		{
			if (NormalizedHealth(EventPlayer()) != 1)
			{
				Heal(EventPlayer(), null, 75);
			}
			if (NormalizedHealth(EventPlayer()) == 1)
			{
				Heal(SortedArray(FilteredArray(PlayersWithinRadius(EventPlayer(), 15, Team.Team1, RadiusLOS.Off), ArrayElement().pIsCombatant && !ArrayElement().pDownedStartT && NormalizedHealth(ArrayElement()) != 1), NormalizedHealth(ArrayElement()))[0], null, 75);
			}
			Wait(0.25, WaitBehavior.IgnoreCondition);
		}
		pActiveAbCooldown = 25;
	}
	else if (pActiveAbNumber == 7)
	{
		pActiveAbVar = RayCastHitPosition(EyePosition(EventPlayer()), EyePosition(EventPlayer()) + 100 * FacingDirectionOf(EventPlayer()), AllPlayers(Team.Team2), null, true);
		PlayEffect(AllPlayers(), PlayEffect.GoodExplosion, Color.White, pActiveAbVar, 8);
		PlayEffect(AllPlayers(), PlayEffect.ExplosionSound, Color.White, pActiveAbVar, 200);
		for (pActiveAbCooldown = -6; 0; 1)
		{
			gTemp1 = FilteredArray(AllLivingPlayers(Team.Team2), !HasStatus(ArrayElement(), Status.PhasedOut) && !HasStatus(ArrayElement(), Status.Stunned) && DistanceBetween(pActiveAbVar, EyePosition(ArrayElement())) <= 8);
			StartDamageOverTime(gTemp1, EventPlayer(), 2, 40);
			for (gIterator = 0; CountOf(gTemp1); 1)
			{
				gTemp1[gIterator].pGmutFortifiedBypassEndT = Max(TotalTimeElapsed(), gTemp1[gIterator].pGmutFortifiedBypassEndT);
				SetStatus(gTemp1[gIterator], EventPlayer(), Status.Stunned, gTemp1[gTemp2].pIsFortified ? 0.5 : 1);
			}
			Wait(2, WaitBehavior.IgnoreCondition);
		}
		pActiveAbCooldown = 35;
	}
	else if (pActiveAbNumber == 8)
	{
		gTemp1 = LastOf(SortedArray(FilteredArray(AllLivingPlayers(Team.Team2), !HasStatus(ArrayElement(), Status.PhasedOut) && !ArrayElement().pIvIsPortal && IsInViewAngle(EventPlayer(), ArrayElement(), 45) && IsInLineOfSight(EyePosition(EventPlayer()), EyePosition(ArrayElement()), BarrierLOS.NoBarriersBlock)), DotProduct(FacingDirectionOf(EventPlayer()), DirectionTowards(EyePosition(EventPlayer()), ArrayElement()))));
		if (gTemp1)
		{
			SetStatus(gTemp1, EventPlayer(), Status.Hacked, 5);
			ModifyVariable(pActiveAbVar, Operation.AppendToArray, gTemp1);
			for (gIterator = 4; 1; -1)
			{
				gTemp1 = SortedArray(FilteredArray(RemoveFromArray(AllLivingPlayers(Team.Team2), pActiveAbVar), !HasStatus(ArrayElement(), Status.PhasedOut) && !ArrayElement().pIvIsPortal && IsInLineOfSight(gTemp1, ArrayElement(), BarrierLOS.NoBarriersBlock)), DistanceBetween(gTemp1, ArrayElement()))[0];
				if (gTemp1)
				{
					SetStatus(gTemp1, EventPlayer(), Status.Hacked, gIterator);
					ModifyVariable(pActiveAbVar, Operation.AppendToArray, gTemp1);
				}
				else
				{
					break;
				}
			}
			Damage(pActiveAbVar, EventPlayer(), 5);
			pActiveAbCooldown = -0.8;
			Wait(0.8, WaitBehavior.IgnoreCondition);
			pActiveAbVar = [];
			pActiveAbCooldown = 25;
		}
		else
		{
			pActiveAbCooldown = 1;
		}
	}
	for (pActiveAbCooldown = pActiveAbCooldown; 0; -1)
	{
		Wait(1, WaitBehavior.IgnoreCondition);
	}
}

rule: "Team 1 Doomfist: Meteor Strike (Invisibility 2, not detectable)"
Event.OngoingPlayer
Team.Team1
Player.Doomfist
if (IsUsingUltimate(EventPlayer()))
{
	pIsInvisible = 2;
	WaitUntil(!IsUsingUltimate(EventPlayer()), 99999);
	pIsInvisible = false;
}

rule: "Team 1 D.Va: Fill Ultimate Charge when downed"
Event.OngoingPlayer
Team.Team1
Player.Dva
if (pDownedStartT)
if (UltimateChargePercent(EventPlayer()) != 100)
{
	Wait(0.05, WaitBehavior.AbortWhenFalse);
	SetUltimateCharge(EventPlayer(), 100);
}

rule: "Team 1 Echo: Stealth (Invisibility 1, detectable)"
Event.OngoingPlayer
Team.Team1
Player.Echo
if (HeroBeingDuplicated(EventPlayer()) == Hero.Sombra)
if (IsUsingAbility1(EventPlayer()))
{
	Wait(0.8, WaitBehavior.AbortWhenFalse);
	pIsInvisible = 1;
	WaitUntil(!IsUsingAbility1(EventPlayer()), 99999);
	pIsInvisible = false;
}

rule: "Team 1 Echo: Remove Stealth when Duplicate ends"
Event.OngoingPlayer
Team.Team1
Player.Echo
if (pIsInvisible == 1)
if (!IsDuplicating(EventPlayer()))
{
	pIsInvisible = false;
}

rule: "Team 1 Echo: Cancel Charge on Boss Enemies"
Event.PlayerDealtKnockback
Team.Team1
Player.Echo
{
	AbortIf(HeroBeingDuplicated(EventPlayer()) != Hero.Reinhardt);
	AbortIf(EventAbility() != null);
	AbortIf(!Victim().pIsLivingBoss);
	Damage(Victim(), EventPlayer(), 150);
	CancelPrimaryAction(EventPlayer());
	Victim().pGmutFortifiedBypassEndT = Max(TotalTimeElapsed() + 1.2, Victim().pGmutFortifiedBypassEndT);
	SetStatus(Victim(), EventPlayer(), Status.Stunned, 1.2);
}

rule: "Team 1 Echo: Cancel Chain Hook on Boss Enemies"
Event.OnDamageDealt
Team.Team1
Player.Echo
{
	AbortIf(HeroBeingDuplicated(EventPlayer()) != Hero.Roadhog);
	AbortIf(EventAbility() != Button.Ability1);
	AbortIf(!Victim().pIsLivingBoss);
	AbortIf(!IsUsingAbility1(EventPlayer()));
	CancelPrimaryAction(EventPlayer());
	MinWait();
	Victim().pGmutFortifiedBypassEndT = Max(TotalTimeElapsed() + 1, Victim().pGmutFortifiedBypassEndT);
	SetStatus(Victim(), EventPlayer(), Status.Stunned, 1);
}

rule: "Team 1 Mercy: Revive Ability (Player)"
Event.OngoingPlayer
Team.Team1
Player.Mercy
if (IsButtonHeld(EventPlayer(), Button.Ability2))
if (!AbilityCooldown(EventPlayer(), Button.Ability2))
if (!pDownedStartT)
if (!HasStatus(EventPlayer(), Status.Hacked))
if (!HasStatus(EventPlayer(), Status.Stunned))
{
	pAbPlayer = LastOf(SortedArray(FilteredArray(PlayersWithinRadius(EventPlayer(), 10, Team.Team1, RadiusLOS.Off), ArrayElement().pIsCombatant && ArrayElement().pDownedStartT && ArrayElement().pDownedStartT + 0.1 < TotalTimeElapsed() && IsInViewAngle(EventPlayer(), ArrayElement(), 45)), DotProduct(FacingDirectionOf(EventPlayer()), DirectionTowards(EyePosition(EventPlayer()), ArrayElement()))));
	if (pAbPlayer)
	{
		SmallMessage(AllPlayers(), <"<0> has been resurrected by <1>!", pAbPlayer, EventPlayer()>);
		pAbPlayer.pDownedStartT = false;
		PlayEffect(AllPlayers(), PlayEffect.GoodPickupEffect, Color.SkyBlue, pAbPlayer, 1);
		gTemp1 = (gIsHardModeEnabled || gIsApocalyptic ? 1.5 : 1) * [30, 33.333, 40][pAbHaste];
		SetAbilityCooldown(EventPlayer(), Button.Ability2, gTemp1);
		# Workaround: Set Cooldown for Controller Players
		SetAbilityCooldown(EventPlayer(), Button.SecondaryFire, gTemp1);
	}
	Wait(0.05, WaitBehavior.IgnoreCondition);
}

//> Outdated
rule: "Team 1 Sombra: Stealth (Invisibility 1, detectable), end after 20 seconds"
Event.OngoingPlayer
Team.Team1
Player.Sombra
if (IsUsingAbility1(EventPlayer()))
{
	Wait(0.8, WaitBehavior.AbortWhenFalse);
	pIsInvisible = 1;
	for (pSombraStealthTimer = 100; 0; -0.48)
	{
		WaitUntil(!IsUsingAbility1(EventPlayer()), 0.096);
		if (!IsUsingAbility1(EventPlayer()))
		{
			break;
		}
	}
	if (IsUsingAbility1(EventPlayer()))
	{
		PressButton(EventPlayer(), Button.Ability1);
	}
	pIsInvisible = false;
}

rule: "Team 1 Reinhardt: Cancel Charge on Boss Enemies"
Event.PlayerDealtKnockback
Team.Team1
Player.Reinhardt
{
	AbortIf(EventAbility() != null);
	AbortIf(!Victim().pIsLivingBoss);
	Damage(Victim(), EventPlayer(), 250);
	CancelPrimaryAction(EventPlayer());
	Victim().pGmutFortifiedBypassEndT = Max(TotalTimeElapsed() + 1.2, Victim().pGmutFortifiedBypassEndT);
	SetStatus(Victim(), EventPlayer(), Status.Stunned, 1.2);
}

rule: "Team 1 Roadhog: Cancel Chain Hook on Boss Enemies"
Event.OnDamageDealt
Team.Team1
Player.Roadhog
{
	AbortIf(EventAbility() != Button.Ability1);
	AbortIf(!Victim().pIsLivingBoss);
	AbortIf(!IsUsingAbility1(EventPlayer()));
	CancelPrimaryAction(EventPlayer());
	MinWait();
	Victim().pGmutFortifiedBypassEndT = Max(TotalTimeElapsed() + 1, Victim().pGmutFortifiedBypassEndT);
	SetStatus(Victim(), EventPlayer(), Status.Stunned, 1);
}

rule: "Team 1 Tracer: Start Health Regeneration after Recall"
Event.OngoingPlayer
Team.Team1
Player.Tracer
if (IsUsingAbility2(EventPlayer()))
{
	Wait(0.85, WaitBehavior.IgnoreCondition);
	pLastDamageTakenT = false;
}

rule: "Team 1 Zenyatta: Harmony target is harder to hit"
Event.OnHealingDealt
Team.Team1
Player.Zenyatta
{
	AbortIf(EventAbility() != Button.Ability1);
	Healee().pActiveAbIsSmoked = true;
	Wait(1, WaitBehavior.IgnoreCondition);
}

rule: "Team 1: Smoke Screen"
Event.OngoingPlayer
Team.Team1
if (pSmokedScreen)
if (pDownedStartT == 0)
{
	StartForcingPlayerOutlines(AllPlayers(), EventPlayer(), false, Color.White, OutlineType.Default);
	WaitUntil(IsDead(EventPlayer()), 4);
	StopForcingPlayerOutlines(AllPlayers(), EventPlayer());
	pSmokedScreen = false;
	StartForcingPlayerOutlines(FilteredArray(AllPlayers(Team.Team2), ArrayElement().pIsLivingBoss), EventPlayer(), true, Color.Yellow, OutlineType.Always);
}

rule: "Team 1: Is Shattered, Start Accelerating"
Event.OnDamageTaken
Team.Team1
{
	AbortIf(!HasStatus(EventPlayer(), Status.Stunned));
	AbortIf(HeroOf(Attacker()) != Hero.Reinhardt);
	AbortIf(EventAbility() != Button.Ultimate);
	SetStatus(EventPlayer(), Attacker(), Status.Stunned, 5);
	pLastHitByShatterT = TotalTimeElapsed();
	ApplyImpulse(EventPlayer(), DirectionFromAngles(HorizontalAngleFromDirection(EventDirection()), 30), 15, Relative.ToWorld, ContraryMotion.CancelXYZ);
	StartAccelerating(EventPlayer(), DirectionFromAngles(HorizontalAngleFromDirection(EventDirection()), 30), IsInAir(EventPlayer()) ? 100 : (1 - (TotalTimeElapsed() - pLastHitByShatterT)) * 500, 15, Relative.ToWorld, AccelerateRev.DirectionRateAndMaxSpeed);
	Wait(1, WaitBehavior.IgnoreCondition);
	ClearStatus(EventPlayer(), Status.Stunned);
	StopAccelerating(EventPlayer());
}

rule: "Widowmaker: Widowmaker Ult"
Event.OngoingPlayer
Team.Team1
Player.Widowmaker
if (IsUsingUltimate(EventPlayer()))
{
	AllPlayers(Team.Team2).pSlowedUntil = 9999 + TotalTimeElapsed();
	WaitUntil(!IsUsingUltimate(EventPlayer()), 9999);
	AllPlayers(Team.Team2).pSlowedUntil = TotalTimeElapsed();
}
