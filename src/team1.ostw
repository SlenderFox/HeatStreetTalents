import "globalvars.ostw";
import "playervars.ostw";
import "subroutines.ostw";

globalvar Boolean gIsHardModeEnabled;
globalvar Boolean gMutDeepWounds;
globalvar Number gMoneyMult;
globalvar Vector gBuyMenuCamPos;
globalvar Vector gPlayerSpawnPos;
globalvar Vector gPlayerSpawnFacing;
globalvar Vector gAbilityShopPos;
globalvar String[] gProgressBarStrings;

playervar Number pHealMod;
playervar Number[] pDamageReceived;
playervar Number pActiveAbNumber;
playervar Number pActiveAbCooldown;
playervar Vector pDeathCamTarget;
playervar Player pSpectatedPlayer;
playervar Any pNemesisBeamEffect;
playervar Any pActiveAbVar; // Both vector and player

void open_buy_menu() "Subroutine: Open Buy Menu, Last Facing (3)"
{
	AbortIf(pDownedStartT
		|| NormalizedHealth(EventPlayer()) < 0.5
		|| HasStatus(EventPlayer(), Status.Stunned)
		|| pTasedEndT >= TotalTimeElapsed()
	);
	ApplyImpulse(
		EventPlayer(),
		-1 * DirectionFromAngles(HorizontalAngleFromDirection(VelocityOf(EventPlayer())), false),
		0.001,
		Relative.ToWorld,
		ContraryMotion.CancelXYZ
	);
	pAbVar3 = EventPlayer().FacingDirection();
	pInBuyMenu = TotalTimeElapsed();
	DisableHeroHud(EventPlayer());
	SetFacing(EventPlayer(), Forward(), Relative.ToWorld);
	StartCamera(EventPlayer(), gBuyMenuCamPos, gBuyMenuCamPos + gBuyMenuLeftUpForward[2], 0);
	disable_player();
	SetAimSpeed(EventPlayer(), 200);
}

void leave_buy_menu() "Subroutine: Leave Buy Menu"
{
	pInBuyMenu = false;
	EnableHeroHud(EventPlayer());
	SetFacing(EventPlayer(), pAbVar3, Relative.ToWorld);
	if (!pDownedStartT)
	{
		StopCamera(EventPlayer());
		enable_player();
	}
	SetAimSpeed(EventPlayer(), 100);
}

void check_if_enough_money() "Subroutine: Check if enough money"
{
	if (gMoneyMult * gMoneyAmount - pMoneySpentAmount >= gTemp2)
	{
		pMoneySpentAmount += gTemp2;
		//SmallMessage(EventPlayer(), " Ability unlocked");
		play_purchase_confirmation_sound();
	}
	else
	{
		gTemp2 = false;
		SmallMessage(EventPlayer(), "Not enough money");
	}
}

void buy_active_ability() "Subroutine: Buy Active Ability"
{
	if (!pActiveAbNumber)
	{
		gTemp2 = 1200;
		check_if_enough_money();
		AbortIf(!gTemp2);
	}
	else if (gTemp1 == pActiveAbNumber)
	{
		Abort();
	}
	else
	{
		SmallMessage(EventPlayer(), "Swapped Active Ability");
	}
	remove_active_ability();
	pActiveAbNumber = gTemp1;
	if (gTemp1 == 1)
	{
		CreateEffect(
			pActiveAbCooldown < 0 ? AllPlayers(Team.All) : [],
			Effect.AnaNanoBoostedEffect,
			Color.Team1,
			EventPlayer(),
			1,
			EffectRev.VisibleTo
		);
		pActiveAbEffectList.ModAppend(LastCreatedEntity());
	}
	else if (gTemp1 == 2)
	{
		CreateEffect(
			pActiveAbCooldown < 0 ? AllPlayers(Team.All) : [],
			Effect.ReaperWraithFormEffect,
			Color.Team1,
			EventPlayer(),
			1,
			EffectRev.VisibleTo
		);
		pActiveAbEffectList.ModAppend(LastCreatedEntity());
	}
	else if (gTemp1 == 4)
	{
		CreateEffect(
			pActiveAbCooldown < 0 ? AllPlayers(Team.All) : [],
			Effect.BaptisteImmortalityFieldProtectedEffect,
			Color.Team1,
			EventPlayer(),
			1,
			EffectRev.VisibleTo
		);
		pActiveAbEffectList.ModAppend(LastCreatedEntity());
	}
	else if (gTemp1 == 5)
	{
		pActiveAbVar = 1000 * Down();
		CreateEffect(
			pActiveAbCooldown < 0 ? AllPlayers(Team.All) : [],
			Effect.Cloud,
			Color.SkyBlue,
			pActiveAbVar + 2 * Up(),
			10,
			EffectRev.VisibleToPositionAndRadius
		);
		pActiveAbEffectList.ModAppend(LastCreatedEntity());
		CreateEffect(
			pActiveAbCooldown < 0 ? AllPlayers(Team.All) : [],
			Effect.Cloud,
			Color.SkyBlue,
			pActiveAbVar + 2 * Down(),
			10,
			EffectRev.VisibleToPositionAndRadius
		);
		pActiveAbEffectList.ModAppend(LastCreatedEntity());
		CreateEffect(
			pActiveAbCooldown < 0 ? AllPlayers(Team.All) : [],
			Effect.Ring,
			Color.SkyBlue,
			pActiveAbVar + Down(),
			10,
			EffectRev.VisibleToPositionAndRadius
		);
		pActiveAbEffectList.ModAppend(LastCreatedEntity());
	}
	else if (gTemp1 == 6)
	{
		CreateEffect(
			pActiveAbCooldown < 0 ? AllPlayers(Team.All) : [],
			Effect.HealTargetActiveEffect,
			Color.Team1,
			EventPlayer(),
			1,
			EffectRev.VisibleTo
		);
		pActiveAbEffectList.ModAppend(LastCreatedEntity());
	}
	else if (gTemp1 == 7)
	{
		pActiveAbVar = 1000 * Down();
		CreateEffect(
			pActiveAbCooldown < 0 ? AllPlayers(Team.All) : [],
			Effect.Cloud,
			Color.Yellow,
			pActiveAbVar + Up(),
			8,
			EffectRev.VisibleToPositionAndRadius
		);
		pActiveAbEffectList.ModAppend(LastCreatedEntity());
		CreateEffect(
			pActiveAbCooldown < 0 ? AllPlayers(Team.All) : [],
			Effect.Cloud,
			Color.Yellow,
			pActiveAbVar + Down(),
			8,
			EffectRev.VisibleToPositionAndRadius
		);
		pActiveAbEffectList.ModAppend(LastCreatedEntity());
	}
	else if (gTemp1 == 8)
	{
		pActiveAbVar = [];
		CreateBeamEffect(
			CountOf(pActiveAbVar) ? AllPlayers(Team.All) : [],
			BeamType.BadBeam,
			EventPlayer(),
			pActiveAbVar[0],
			Color.Purple,
			EffectRev.VisibleToPositionAndRadius
		);
		pActiveAbEffectList.ModAppend(LastCreatedEntity());
		CreateBeamEffect(
			CountOf(pActiveAbVar) > 1 ? AllPlayers(Team.All) : [],
			BeamType.BadBeam,
			pActiveAbVar[0],
			pActiveAbVar[1],
			Color.Purple,
			EffectRev.VisibleToPositionAndRadius
		);
		pActiveAbEffectList.ModAppend(LastCreatedEntity());
		CreateBeamEffect(
			CountOf(pActiveAbVar) > 2 ? AllPlayers(Team.All) : [],
			BeamType.BadBeam,
			pActiveAbVar[1],
			pActiveAbVar[2],
			Color.Purple,
			EffectRev.VisibleToPositionAndRadius
		);
		pActiveAbEffectList.ModAppend(LastCreatedEntity());
		CreateBeamEffect(
			CountOf(pActiveAbVar) > 3 ? AllPlayers(Team.All) : [],
			BeamType.BadBeam,
			pActiveAbVar[2],
			pActiveAbVar[3],
			Color.Purple,
			EffectRev.VisibleToPositionAndRadius
		);
		pActiveAbEffectList.ModAppend(LastCreatedEntity());
	}
	play_purchase_confirmation_sound();
}

void remove_active_ability() "Subroutine: Remove Active Ability"
{
	if (pActiveAbCooldown < 0)
	{
		pActiveAbCooldown = -0.1;
	}
	DestroyEffect(pActiveAbEffectList);
	pActiveAbEffectList = [];
	pActiveAbNumber = false;
}

void play_purchase_confirmation_sound() "Subroutine: Play Purchase Confirmation Sound"
{
	PlayEffect(EventPlayer(), PlayEffect.BuffExplosionSound, Color.White, gBuyMenuCamPos, 200);
}

void disable_player() "Subroutine: Disable Player"
{
	ForceThrottle(EventPlayer(), false, 0.1, false, 0.1, false, 0.1);
	SetPrimaryFireEnabled(EventPlayer(), false);
	SetSecondaryFireEnabled(EventPlayer(), false);
	SetAbility1Enabled(EventPlayer(), false);
	SetAbility2Enabled(EventPlayer(), false);
	SetMeleeEnabled(EventPlayer(), false);
	SetJumpEnabled(EventPlayer(), false);
	SetCrouchEnabled(EventPlayer(), false);
	DisallowButton(EventPlayer(), Button.Ultimate);
}

void enable_player() "Subroutine: Enable Player"
{
	StopForcingThrottle(EventPlayer());
	SetPrimaryFireEnabled(EventPlayer(), true);
	SetSecondaryFireEnabled(EventPlayer(), true);
	SetAbility1Enabled(EventPlayer(), true);
	SetAbility2Enabled(EventPlayer(), true);
	SetMeleeEnabled(EventPlayer(), true);
	SetJumpEnabled(EventPlayer(), true);
	SetCrouchEnabled(EventPlayer(), true);
	AllowButton(EventPlayer(), Button.Ultimate);
}

rule: "[Tutorial] Close HUD"
Event.OngoingPlayer
if (pTutActive)
if (IsButtonHeld(EventPlayer(), Button.Reload))
if (IsButtonHeld(EventPlayer(), Button.Crouch))
if (IsAlive(EventPlayer()))
{
	Wait(0.25, WaitBehavior.IgnoreCondition);
	pTutActive = false;
	//SmallMessage(EventPlayer(), <" press <0> + <1> to toggle hero changes", InputBindingString(Button.Crouch), InputBindingString(Button.Reload)>);
}

rule: "[Tutorial] Open HUD"
Event.OngoingPlayer
if (!pTutActive)
if (IsButtonHeld(EventPlayer(), Button.Reload))
if (IsButtonHeld(EventPlayer(), Button.Crouch))
if (IsAlive(EventPlayer()))
{
	Wait(0.25, WaitBehavior.IgnoreCondition);
	pTutActive = true;
}

rule: "Team 1: Player Damage Automater (+-)"
Event.OngoingPlayer
Team.Team1
if (pDamageDealt[true] != pDamageDealt[false])
{
	pDamageDealt[true] = pDamageDealt[false];
	SetDamageDealt(EventPlayer(), pDamageDealt[true]);
}

rule: "Team 1: Player HP Automater (+-)"
Event.OngoingPlayer
Team.Team1
if (pHealthPercent[true] != pHealthPercent[false])
{
	pHealthPercent[true] = pHealthPercent[false];
	SetMaxHealth(EventPlayer(), pHealthPercent[true]);
}

rule: "Team 1: Player Resistance Automater (+-)"
Event.OngoingPlayer
Team.Team1
if (pDamageReceived[true] != pDamageReceived[false])
{
	pDamageReceived[true] = pDamageReceived[false];
	SetDamageReceived(EventPlayer(), pDamageReceived[true]);
}

rule: "Team 1: Player Move Speed Automater (+-)"
Event.OngoingPlayer
Team.Team1
if (pMoveSpeed[true] != pMoveSpeed[false])
{
	pMoveSpeed[true] = pMoveSpeed[false];
	SetMoveSpeed(EventPlayer(), pMoveSpeed[true]);
}

rule: "Team 1: Player Healing Automater (+-)"
Event.OngoingPlayer
Team.Team1
if (pHealingDealtPercent[true] != pHealingDealtPercent[false])
{
	pHealingDealtPercent[true] = pHealingDealtPercent[false];
	SetHealingDealt(EventPlayer(), pHealingDealtPercent[true]);
}

rule: "Team 1: Protect from One-shots if health is over 50%"
Event.OngoingPlayer
Team.Team1
if (NormalizedHealth(EventPlayer()) >= 0.5)
{
	SetStatus(EventPlayer(), null, Status.Unkillable, 9999);
	WaitUntil(NormalizedHealth(EventPlayer()) < 0.5, 99999);
	Wait(0.4, WaitBehavior.RestartWhenTrue);
	LoopIfConditionIsTrue();
	ClearStatus(EventPlayer(), Status.Unkillable);
}

rule: "Team 1 Button: Interact, Open / Leave Buy Menu"
Event.OngoingPlayer
Team.Team1
if (IsButtonHeld(EventPlayer(), Button.Interact))
{
	if (pInBuyMenu)
	{
		leave_buy_menu();
	}
	else if (DistanceBetween(EventPlayer(), gAbilityShopPos) <= 2)
	{
		open_buy_menu();
	}
	else if (pCanUseDropInBuyMenu || MatchTime())
	{
		Wait(0.4, WaitBehavior.AbortWhenFalse);
		open_buy_menu();
	}
	Wait(0.05, WaitBehavior.IgnoreCondition);
}

rule: "Team 1: Leave Buy Menu when downed, health low, stunned or tased"
Event.OngoingPlayer
Team.Team1
if (pInBuyMenu)
if (pDownedStartT || NormalizedHealth(EventPlayer()) < 0.5 || HasStatus(EventPlayer(), Status.Stunned) || pTasedEndT >= TotalTimeElapsed())
{
	leave_buy_menu();
	AbortIf(NormalizedHealth(EventPlayer()) > 0.4);
	EventPlayer().SetMaxHealth(0.4 * EventPlayer().MaxHealth());
}

rule: "Team 1: Toggle Show active Ability"
Event.OngoingPlayer
Team.Team1
if (pInBuyMenu)
if (IsButtonHeld(EventPlayer(), Button.Melee))
{
	AbortIf(pInBuyMenu + 0.1 >= TotalTimeElapsed());
	pIsShowingActiveAbilities = !pIsShowingActiveAbilities;
}

rule: "Team 1: Buy Ability"
Event.OngoingPlayer
Team.Team1
if (pInBuyMenu)
if (IsButtonHeld(EventPlayer(), Button.PrimaryFire))
{
	AbortIf(pInBuyMenu + 0.1 >= TotalTimeElapsed()
		|| AbsoluteValue(HorizontalFacingAngleOf(EventPlayer())) >= 135
		|| AbsoluteValue(VerticalFacingAngleOf(EventPlayer()) + 11.25) >= 45
		|| pTasedEndT >= TotalTimeElapsed()
	);
	# Grid coordinates of selected panel
	gTemp1 = [RoundToInteger((HorizontalFacingAngleOf(EventPlayer()) + 135) / 45, Rounding.Down), RoundToInteger((VerticalFacingAngleOf(EventPlayer()) + 56.25) / 22.5, Rounding.Down)];
	if (gTemp1[1] == 0)
	{
		if (gTemp1[0] <= 1)
		{
			leave_buy_menu();
		}
		else if (gTemp1[0] <= 3)
		{
			pIsShowingActiveAbilities = !pIsShowingActiveAbilities;
		}
		else
		{
			if (pMoneySpentAmount)
			{
				remove_active_ability();
				pMoneySpentAmount = false;
				pAbHeadhunter = false;
				pAbQuickFix = false;
				pAbCharged = false;
				pAbHeavyImpact = false;
				pAbSecondWind = false;
				pAbTriage = false;
				if (pAbResilience)
				{
					pAbResilience = false;
					pDamageReceived += 20;
				}
				SetKnockbackDealt(EventPlayer(), 100);
				SetKnockbackReceived(EventPlayer(), 100);
				pAbAntigens = false;
				StopHealingModification(pHealMod[1]);
				StopHealOverTime(pHealMod[2]);
				StopDamageModification(pDamageMod[11]);
				StopDamageModification(pDamageMod[12]);
				pAbHaste = false;
				pAbPriority = false;
				pHealthPercent -= pAbHealthBonus;
				pAbHealthBonus = false;
				pDamageDealt -= pAbDamageBonus;
				pAbDamageBonus = false;
				pHealingDealtPercent -= pAbHealingBonus;
				pAbHealingBonus = false;
				pPerkBulletStorm = false;
				pPerkDieHard = false;
				pPerkBrassKnuckles = false;
				pPerkVampiric = false;
				pPerkCrashNDash = false;
				pPerkGoldenHour = false;
				pPerkSuperCharge = false;
				if (pPerkNemesis)
				{
					DestroyEffect(pNemesisBeamEffect);
					pPerkNemesis = false;
				}
				if (pPerkSpecialOperator)
				{
					RemoveHealthPoolFromPlayer(pHpPool[2]);
					pPerkSpecialOperator = false;
				}
				pPerkSharpShooter = false;
				StopDamageModification(pDamageMod[10]);
				pTalent1 = false;
				pTalent2 = false;
				if (pPerkMysterySwap)
				{
					pHealthPercent -= 20;
					pDamageDealt -= 20;
					pHealingDealtPercent -= 20;
					StopForcingHero(EventPlayer());
					pPerkMysterySwap = false;
				}
				if (pPerkShockProof)
				{
					EnableMovementCollisionWithPlayers(EventPlayer());
					pMoveSpeed -= 15;
					MinWait();
					pPerkShockProof = false;
				}
				SmallMessage(EventPlayer(), " Money Refunded");
				update_ab_string_and_play_sound();
				Abort();
			}
		}
	}
	else
	{
		if (gTemp1[0] == 0)
		{
			if (gTemp1[1] >= 2)
			{
				// Current perks contains the two random perks, access using boolean value
				gTemp2 = gCurrentPerks[gTemp1[1] >= 3];
				if (gTemp2 == 0)
				{
					if (!pPerkMysterySwap)
					{
						gTemp2 = 500;
						check_if_enough_money();
						if (gTemp2)
						{
							pHealthPercent += 20;
							pDamageDealt += 20;
							pHealingDealtPercent += 20;
							pPerkMysterySwap = TotalTimeElapsed() + 90;
							update_ab_string_and_play_sound();
						}
					}
				}
				else if (gTemp2 == 1)
				{
					if (!pPerkBulletStorm)
					{
						gTemp2 = 1000;
						check_if_enough_money();
						if (gTemp2)
						{
							pPerkBulletStorm = true;
							update_ab_string_and_play_sound();
						}
					}
				}
				else if (gTemp2 == 2)
				{
					if (!pPerkDieHard)
					{
						gTemp2 = 700;
						check_if_enough_money();
						if (gTemp2)
						{
							pPerkDieHard = true;
							update_ab_string_and_play_sound();
						}
					}
				}
				else if (gTemp2 == 3)
				{
					if (!pPerkBrassKnuckles)
					{
						gTemp2 = 700;
						check_if_enough_money();
						if (gTemp2)
						{
							pPerkBrassKnuckles = true;
							update_ab_string_and_play_sound();
						}
					}
				}
				else if (gTemp2 == 4)
				{
					if (!pPerkVampiric)
					{
						gTemp2 = 1000;
						check_if_enough_money();
						if (gTemp2)
						{
							pPerkVampiric = true;
							update_ab_string_and_play_sound();
						}
					}
				}
				else if (gTemp2 == 5)
				{
					if (!pPerkCrashNDash)
					{
						gTemp2 = 700;
						check_if_enough_money();
						if (gTemp2)
						{
							pPerkCrashNDash = true;
							update_ab_string_and_play_sound();
						}
					}
				}
				else if (gTemp2 == 6)
				{
					if (!pPerkGoldenHour)
					{
						gTemp2 = 1000;
						check_if_enough_money();
						if (gTemp2)
						{
							pPerkGoldenHour = true;
							update_ab_string_and_play_sound();
						}
					}
				}
				else if (gTemp2 == 7)
				{
					if (!pPerkSuperCharge)
					{
						gTemp2 = 700;
						check_if_enough_money();
						if (gTemp2)
						{
							pPerkSuperCharge = true;
							update_ab_string_and_play_sound();
						}
					}
				}
				else if (gTemp2 == 8)
				{
					if (!pPerkNemesis)
					{
						gTemp2 = 800;
						check_if_enough_money();
						if (gTemp2)
						{
							pPerkNemesis = true;
							CreateBeamEffect(
								pPerkNemesisKiller ? AllPlayers() : [],
								BeamType.BadBeam,
								EventPlayer().Position(),
								pPerkNemesisKiller,
								Color.Black,
								EffectRev.VisibleToPositionAndRadius
							);
							pNemesisBeamEffect = LastCreatedEntity();
							update_ab_string_and_play_sound();
						}
					}
				}
				else if (gTemp2 == 9)
				{
					if (!pPerkSpecialOperator)
					{
						gTemp2 = 600;
						check_if_enough_money();
						if (gTemp2)
						{
							pHpPool[2] = AddHealthPoolToPlayer(EventPlayer(), HealthType.Armor, 50, true, true);
							pPerkSpecialOperator = true;
							update_ab_string_and_play_sound();
						}
					}
				}
				else if (gTemp2 == 10)
				{
					if (!pPerkSharpShooter)
					{
						gTemp2 = 900;
						check_if_enough_money();
						if (gTemp2)
						{
							pPerkSharpShooter = true;
							pDamageMod[10] = StartDamageModification(
								AllPlayers(Team.Team2).Filter(p => DistanceBetween(EventPlayer(), p) > 20),
								EventPlayer(),
								150,
								DamageModificationRev.ReceiversDamagersAndDamagePercent
							);
							update_ab_string_and_play_sound();
						}
					}
				}
				else if (gTemp2 == 11)
				{
					if (!pPerkShockProof)
					{
						gTemp2 = 700;
						check_if_enough_money();
						if (gTemp2)
						{
							//DisableMovementCollisionWithPlayers(EventPlayer());
							//pMoveSpeed += 15;
							pPerkShockProof = true;
							update_ab_string_and_play_sound();
						}
					}
				}
				else if (gTemp2 == 12)
				{
					if (!pTalent1)
					{
						gTemp2 = 1600;
						check_if_enough_money();
						if (gTemp2)
						{
							pTalent1 = true;
							update_ab_string_and_play_sound();
						}
					}
				}
				else if (gTemp2 == 13)
				{
					if (!pTalent2)
					{
						gTemp2 = 1600;
						check_if_enough_money();
						if (gTemp2)
						{
							pTalent2 = true;
							update_ab_string_and_play_sound();
						}
					}
				}
			}
		}
		else if (gTemp1[0] == 1)
		{
			if (pIsShowingActiveAbilities)
			{
				if (gTemp1[1] == 1)
				{
					gTemp1 = 4;
					buy_active_ability();
				}
				else if (gTemp1[1] == 2)
				{
					gTemp1 = 8;
					buy_active_ability();
				}
			}
			else
			{
				gTemp2 = 500;
				check_if_enough_money();
				if (gTemp2)
				{
					if (gTemp1[1] == 1)
					{
						pAbHealthBonus += 5;
						pHealthPercent += 5;
					}
					else if (gTemp1[1] == 2)
					{
						pAbDamageBonus += 5;
						pDamageDealt += 5;
						SetDamageDealt(EventPlayer(), pDamageDealt[0]);
					}
					else
					{
						pAbHealingBonus += 5;
						pHealingDealtPercent += 5;
					}
					update_ab_string_and_play_sound();
				}
			}
		}
		else if (gTemp1[0] == 2)
		{
			if (pIsShowingActiveAbilities)
			{
				if (gTemp1[1] == 1)
				{
					gTemp1 = 3;
					buy_active_ability();
				}
				else if (gTemp1[1] == 2)
				{
					gTemp1 = 7;
					buy_active_ability();
				}
			}
			else
			{
				if (gTemp1[1] == 1)
				{
					if (pAbSecondWind < 2)
					{
						gTemp2 = 1000;
						check_if_enough_money();
						if (gTemp2)
						{
							pAbSecondWind = pAbSecondWind ? 2 : 1;
							update_ab_string_and_play_sound();
						}
					}
				}
				else if (gTemp1[1] == 2)
				{
					if (pAbTriage < 2)
					{
						gTemp2 = 700;
						check_if_enough_money();
						if (gTemp2)
						{
							pAbTriage = pAbTriage ? 2 : 1;
							update_ab_string_and_play_sound();
						}
					}
				}
				else
				{
					if (pAbResilience < 2)
					{
						gTemp2 = 800;
						check_if_enough_money();
						if (gTemp2)
						{
							pAbResilience = pAbResilience ? 2 : 1;
							pDamageReceived -= 20;
							SetKnockbackDealt(EventPlayer(), 100 + 30 * pAbResilience);
							SetKnockbackReceived(EventPlayer(), 100 - 30 * pAbResilience);
							update_ab_string_and_play_sound();
						}
					}
				}
			}
		}
		else if (gTemp1[0] == 3)
		{
			if (pIsShowingActiveAbilities)
			{
				if (gTemp1[1] == 1)
				{
					gTemp1 = 2;
					buy_active_ability();
				}
				else if (gTemp1[1] == 2)
				{
					gTemp1 = 6;
					buy_active_ability();
				}
			}
			else
			{
				if (gTemp1[1] == 1)
				{
					if (pAbCharged < 2)
					{
						gTemp2 = 700;
						check_if_enough_money();
						if (gTemp2)
						{
							pAbCharged = pAbCharged ? 2 : 1;
							update_ab_string_and_play_sound();
						}
					}
				}
				else if (gTemp1[1] == 2)
				{
					if (pAbHaste < 2)
					{
						gTemp2 = 800;
						check_if_enough_money();
						if (gTemp2)
						{
							pAbHaste = pAbHaste ? 2 : 1;
							update_ab_string_and_play_sound();
						}
					}
				}
				else
				{
					if (pAbHeavyImpact < 2)
					{
						gTemp2 = 1000;
						check_if_enough_money();
						if (gTemp2)
						{
							pAbHeavyImpact = pAbHeavyImpact ? 2 : 1;
							update_ab_string_and_play_sound();
						}
					}
				}
			}
		}
		else if (gTemp1[0] == 4)
		{
			if (pIsShowingActiveAbilities)
			{
				if (gTemp1[1] == 1)
				{
					gTemp1 = 1;
					buy_active_ability();
				}
				else if (gTemp1[1] == 2)
				{
					gTemp1 = 5;
					buy_active_ability();
				}
			}
			else
			{
				if (gTemp1[1] == 1)
				{
					if (pAbHeadhunter < 2)
					{
						gTemp2 = 800;
						check_if_enough_money();
						if (gTemp2)
						{
							pAbHeadhunter = pAbHeadhunter ? 2 : 1;
							update_ab_string_and_play_sound();
						}
					}
				}
				else if (gTemp1[1] == 2)
				{
					if (pAbAntigens < 2)
					{
						gTemp2 = 600;
						check_if_enough_money();
						if (gTemp2)
						{
							StopHealingModification(pHealMod[1]);
							StopHealOverTime(pHealMod[2]);
							pAbAntigens = pAbAntigens ? 2 : 1;
							pHealMod[1] = StartHealingModification(
								EventPlayer(),
								AllPlayers(),
								100 + 20 * pAbAntigens,
								HealingModificationRev.ReceiversDamagersAndDamagePercent
							);
							pHealMod[2] = StartHealOverTime(
								EventPlayer(),
								null,
								9999,
								MaxHealth(EventPlayer()) * 0.01 * pAbAntigens
							);
							update_ab_string_and_play_sound();
						}
					}
				}
				else
				{
					if (pAbQuickFix < 2)
					{
						gTemp2 = 700;
						check_if_enough_money();
						if (gTemp2)
						{
							pAbQuickFix = pAbQuickFix ? 2 : 1;
							update_ab_string_and_play_sound();
						}
					}
				}
			}
		}
		else
		{
			if (!pAbPriority)
			{
				gTemp2 = 1200;
				check_if_enough_money();
				if (!gTemp2)
				{
					Wait(0.1, WaitBehavior.IgnoreCondition);
					Abort();
				}
			}
			else if (gTemp1[1] == pAbPriority)
			{
				Wait(0.1, WaitBehavior.IgnoreCondition);
				Abort();
			}
			else
			{
				SmallMessage(EventPlayer(), " Swapped Priority");
			}
			pAbPriority = gTemp1[1];
			update_ab_string_and_play_sound();
		}
	}
	Wait(0.1, WaitBehavior.IgnoreCondition);
}

rule: "Team 1 (Spawn): Player Init, Create Effects, Set Is Combatant"
Event.OngoingPlayer
Team.Team1
if (HasSpawned(EventPlayer()))
{
	# Fail-Safe if player somehow despawned (Like Echo duplicating D.Va)
	AbortIf(pIsCombatant);
	//SmallMessage(EventPlayer(), "*******​ ​***********​ PvE: Talents​ | 3.4.6 ​***​ LemonAid");
	# Triage: Players to Players Healing Increase
	StartHealingModification(
		gCombatants.Filter(p => NormalizedHealth(p) <= 0.5),
		EventPlayer(),
		100 + 25 * pAbTriage,
		HealingModificationRev.ReceiversDamagersAndDamagePercent
	);
	pIsCombatant = true;
	// ??
	pSpectatedPlayer = EventPlayer();
	pAbBoughtAbilitiesString = "";
	pHealthPercent = 100;
	pHealingDealtPercent = 100;
	SetHealingReceived(EventPlayer(), 85 + 2.5 * gUpgradeCount);
	update_combatants();
	CreateEffect(
		pDownedStartT ? AllPlayers() : [],
		Effect.Ring,
		Color.Yellow,
		EventPlayer(),
		3,
		EffectRev.VisibleTo
	);
	CreateIcon(
		pDownedStartT ? AllPlayers().Remove(EventPlayer()) : [],
		EventPlayer(),
		Icon.Skull,
		IconRev.VisibleTo,
		Color.Yellow,
		true
	);
	# Workaround: Normalized Health sometimes doesn't reevaluate, so force with TTE
	CreateHudText(
		AllPlayers(Team.Team1),
		"{0}{1}".Format([
			HeroIconString(EventPlayer().Hero()),
			pDownedStartT && pReviveTimer
				? gProgressBarStrings[RoundToInteger(pReviveTimer / 10, Rounding.Down)]
				: ""
		]),
		"{0}{1}{2}".Format([
			EventPlayer(),
			pAbPriority ? ["(A)", "(B)", "(C)"][pAbPriority - 1] : "",
			pInBuyMenu ? "(In Shop)" : ""
		]),
		"{0}{1}".Format([
			pDownedStartT
				? pReviveTimer
					? "Being Revived"
					: "Downed"
				: pIsChangedHeroes
					? "Changing Heroes"
					: "{0} HP".Format([RoundToInteger(EventPlayer().Health(), Rounding.Up)]),
			", ${0}".Format([RoundToInteger(gMoneyMult * gMoneyAmount - pMoneySpentAmount, Rounding.Down)])
		]),
		Location.Left,
		LocalPlayer() == EventPlayer() ? -1 : SlotOf(EventPlayer()),
		pDownedStartT
			? Color.Red
			: pIsChangedHeroes || NormalizedHealth(EventPlayer()) >= 0.5
				? LocalPlayer() == EventPlayer()
					? Color.Green
					: Color.SkyBlue
				: Color.Orange,
		pDownedStartT
			? Color.Red
			: pIsChangedHeroes || NormalizedHealth(EventPlayer()) >= 0.5
			? LocalPlayer() == EventPlayer()
				? Color.Green
				: Color.SkyBlue
			: Color.Orange,
		pDownedStartT
			? Color.Red
			: pIsChangedHeroes || NormalizedHealth(EventPlayer()) >= 0.5
				? LocalPlayer() == EventPlayer()
					? Color.Green
					: Color.SkyBlue
				: Color.Orange,
		HudTextRev.VisibleToSortOrderStringAndColor,
		Spectators.DefaultVisibility
	);
	# Stats
	pDamageReceived = 100;
	pDamageDealt = 100;
	pMoveSpeed = 100;
	# Ability lists
	CreateHudText(
		pIsCombatant ? EventPlayer() : [],
		null,
		pAbBoughtAbilitiesString,
		"{0}{1}".Format([
			pTalent1 ? "\n{0}{1}".Format([AbilityIconString(Hero.Pharah, Button.Jump), pTalentText[0]]) : "",
			pTalent2 ? "\n{0}{1}".Format([AbilityIconString(Hero.Pharah, Button.Jump), pTalentText[2]]) : ""
		]).Slice(1, 100),
		Location.Left,
		10,
		null,
		Color.Green,
		Color.Blue,
		HudTextRev.VisibleToAndString,
		Spectators.DefaultVisibility
	);
	//# Talent 1
	//CreateHudText(
	//	pTalent1 ? EventPlayer() : [],
	//	"",
	//	pTalentText[1],
	//	pTalentText[0],
	//	Location.Left,
	//	11,
	//	Color.Blue,
	//	Color.White,
	//	Color.SkyBlue,
	//	HudTextRev.VisibleToAndString,
	//	Spectators.DefaultVisibility
	//);
	//# Talent 2
	//CreateHudText(
	//	pTalent2 ? EventPlayer() : [],
	//	"",
	//	pTalentText[3],
	//	pTalentText[2],
	//	Location.Left,
	//	12,
	//	Color.Blue,
	//	Color.White,
	//	Color.SkyBlue,
	//	HudTextRev.VisibleToAndString,
	//	Spectators.DefaultVisibility
	//);
	CreateHudText(
		pActiveAbNumber ? EventPlayer() : [],
		AbilityIconString(
			[Hero.Ana, Hero.Sombra, Hero.Soldier76, Hero.Reaper, Hero.Cassidy, Hero.Baptiste, Hero.Sigma, Hero.Sombra][pActiveAbNumber - 1],
			 [Button.Ultimate, Button.Ability1, Button.Ability1, Button.Ability1, Button.Ability2, Button.Ability1, Button.Ultimate, Button.SecondaryFire][pActiveAbNumber - 1]
		),
		"Hold or double tap {0}".Format([InputBindingString(Button.Melee)]),
		"{0}: {1}".Format([
			["Stim Infusion", "Cloak", "Feint", "Frenzy", "Smoke Bomb", "Resurgence", "Tear Gas", "Chain Hack"][pActiveAbNumber - 1],
			pActiveAbCooldown ? RoundToInteger(pActiveAbCooldown, Rounding.Up) : "Ready"
		]),
		Location.Left,
		13,
		pActiveAbCooldown < 0
			? Color.Green
			: HasStatus(EventPlayer(), Status.Hacked) || HasStatus(EventPlayer(), Status.Stunned)
				? Color.Red
				: pActiveAbCooldown
					? Color.Gray
					: Color.Green,
		Color.Orange,
		pActiveAbCooldown < 0
			? Color.Green
			: HasStatus(EventPlayer(), Status.Hacked) || HasStatus(EventPlayer(), Status.Stunned)
				? Color.Red
				: pActiveAbCooldown
					? Color.Gray
					: Color.Green,
		HudTextRev.VisibleToStringAndColor,
		Spectators.DefaultVisibility
	);
	CreateEffect(
		pSmokedScreen && !pPerkSpecialOperator ? EventPlayer() : [],
		Effect.Sphere,
		Color.White,
		EventPlayer(),
		5,
		EffectRev.VisibleToPositionAndRadius
	);
	CreateEffect(
		HasStatus(EventPlayer(), Status.Invincible) ? AllPlayers() : [],
		Effect.BaptisteImmortalityFieldProtectedEffect,
		Team.Team2,
		EventPlayer(),
		1,
		EffectRev.VisibleToPositionAndRadius
	);
	if (gWaveNumber > 0)
	{
		StartForcingPlayerOutlines(
			AllPlayers(Team.Team2).Filter(p => p.pIsLivingBoss),
			EventPlayer(),
			true,
			Color.Yellow,
			OutlineType.Always
		);
		pCanUseDropInBuyMenu = true;
		WaitUntil(pInBuyMenu, 15);
		pCanUseDropInBuyMenu = false;
		if (pInBuyMenu)
		{
			pActiveAbIsCloaked = true;
			SetStatus(EventPlayer(), null, Status.PhasedOut, 30);
			WaitUntil(!pInBuyMenu, 30);
			pActiveAbIsCloaked = false;
			ClearStatus(EventPlayer(), Status.PhasedOut);
		}
	}
	else
	{
		Teleport(EventPlayer(), gPlayerSpawnPos);
		Wait(0.2, WaitBehavior.IgnoreCondition);
		SetFacing(EventPlayer(), gPlayerSpawnFacing, Relative.ToWorld);
	}
}

rule: "Team 1: Add Health Pool"
Event.OngoingPlayer
Team.Team1
if (pIsCombatant)
if (gUpgradeCount > 0)
{
	AddHealthPoolToPlayer(EventPlayer(), HealthType.Health, pHealthPercent * 0.25 * gUpgradeCount, true, true);
}

rule: "Team 1 Button: Hold Reload, Change Hero, Set Last Position (1), Last Eye Position (2), Last Facing (3)"
Event.OngoingPlayer
Team.Team1
if (IsButtonHeld(EventPlayer(), Button.Reload))
{
	Wait(0.4, WaitBehavior.AbortWhenFalse);
	AbortIf(gObjectivePhaseNumber > 0 || pDownedStartT || pInBuyMenu);
	if (pPerkMysterySwap)
	{
		SmallMessage(EventPlayer(), " Mystery Swap prevents you from changing heroes");
		Abort();
	}
	pIsChangedHeroes = true;
	pAbVar1 = EventPlayer().Position();
	pAbVar2 = EventPlayer().EyePosition();
	pAbVar3 = EventPlayer().FacingDirection();
	PlayEffect(AllPlayers(), PlayEffect.GoodPickupEffect, Color.Yellow, pAbVar1, 1);
	StartCamera(EventPlayer(), RayCastHitPosition(pAbVar2, pAbVar2 - 8.25 * DirectionFromAngles(HorizontalAngleFromDirection(pAbVar3), 20), null, null, false) + 0.25 * DirectionFromAngles(HorizontalAngleFromDirection(pAbVar3), 20), pAbVar2, 0);
	ClearStatus(EventPlayer(), Status.Unkillable);
	Kill(EventPlayer(), null);
	# Lower values might cause the player to fall through the map when respawning
	Teleport(EventPlayer(), 100 * Down());
	Wait(0.1, WaitBehavior.IgnoreCondition);
	pIsInvisible = 2;
	WaitUntil(IsAlive(EventPlayer()), 99999);
	StopCamera(EventPlayer());
	Teleport(EventPlayer(), pAbVar1);
	SetFacing(EventPlayer(), pAbVar3, Relative.ToWorld);
	pIsChangedHeroes = false;
	pIsInvisible = false;
	Wait(0.5, WaitBehavior.IgnoreCondition);
	update_ab_string_and_play_sound();
}

rule: "Team 1: Took Damage, Set Last Damage Taken"
Event.OnDamageTaken
Team.Team1
{
	pLastDamageTakenT = TotalTimeElapsed();
}

rule: "Team 1 (Death): Start Camera, Play Sounds, Set is Downed, Revive Timer, Knocked down, Phased out, Death Cam Target"
Event.OnDeath
Team.Team1
if (!pIsChangedHeroes)
{
	if (!pDownedStartT)
	{
		DisableMessages(EventPlayer());
		SmallMessage(AllPlayers(), "{0} was downed!".Format([EventPlayer()]));
		pDeathCamTarget = EventPlayer().EyePosition() + 1000 * DirectionFromAngles(HorizontalFacingAngleOf(EventPlayer()), 0);
		StartCamera(
			EventPlayer(),
			RayCastHitPosition(
				EyePosition(pSpectatedPlayer),
				EyePosition(pSpectatedPlayer) - (pDeathCamTarget
					? 6.25 * DirectionTowards(EyePosition(pSpectatedPlayer), pDeathCamTarget)
					: 8.25 * DirectionFromAngles(HorizontalFacingAngleOf(pSpectatedPlayer), 20)),
				null,
				null,
				false
			) + 0.25 * (pDeathCamTarget
				? DirectionTowards(EyePosition(pSpectatedPlayer), pDeathCamTarget)
				: DirectionFromAngles(HorizontalFacingAngleOf(pSpectatedPlayer), 20)
			),
			EyePosition(pSpectatedPlayer),
			pDeathCamTarget ? 10 : 20
		);
		for (gIterator = 0; CountOf(gCombatants); 1)
		{
			PlayEffect(gCombatants[gIterator], PlayEffect.RingExplosionSound, Color.White, gCombatants[gIterator], 200);
			PlayEffect(gCombatants[gIterator], PlayEffect.RingExplosionSound, Color.White, gCombatants[gIterator], 200);
		}
		pDownedStartT = TotalTimeElapsed();
		pReviveTimer = false;
		if (pPerkNemesis
			&& Attacker().pIsAlive
			&& TeamOf(Attacker()) == Team.Team2
			&& !Attacker().pIvIsPortal
			&& SlotOf(Attacker()) != 1
		)
		{
			pPerkNemesisKiller = Attacker();
		}
		else
		{
			pPerkNemesisKiller = null;
		}
		disable_player();
	}
	if (EventWasEnvironment())
	{
		gTemp1 = NearestWalkablePosition(EventPlayer());
		nwp_teleport();
	}
	Resurrect(EventPlayer());
	ClearStatus(EventPlayer(), Status.PhasedOut);
	SetStatus(EventPlayer(), null, Status.Invincible, 9999);
	// SetStatus(EventPlayer(), null, Status.KnockedDown, 9999);
	Wait(0.05, WaitBehavior.RestartWhenTrue);
	SetPlayerHealth(EventPlayer(), 1);
	SetStatus(EventPlayer(), null, Status.PhasedOut, 9999);
	if (Attacker() != EventPlayer())
	{
		pDeathCamTarget = Attacker();
		Wait(5, WaitBehavior.RestartWhenTrue);
	}
	pDeathCamTarget = null;
}

rule: "Team 1: Player downed fallback"
Event.OngoingPlayer
Team.Team1
if (pDownedStartT)
if (!HasStatus(EventPlayer(), Status.Stunned))
{
	Wait(0.25, WaitBehavior.AbortWhenFalse);
	AbortIfConditionIsFalse();
	StartScalingPlayer(EventPlayer(), 0.5, false);
	disable_player();
	while (pDownedStartT && !HasStatus(EventPlayer(), Status.Hacked))
	{
		ClearStatus(EventPlayer(), Status.PhasedOut);
		CancelPrimaryAction(EventPlayer());
		SetStatus(EventPlayer(), null, Status.Hacked, 9999);
		Wait(0.25, WaitBehavior.IgnoreCondition);
	}
	if (pDownedStartT)
	{
		SetStatus(EventPlayer(), null, Status.PhasedOut, 9999);
	}
	LoopIfConditionIsTrue();
}

rule: "Team 1: Select Next Spectated Player"
Event.OngoingPlayer
Team.Team1
if (pDownedStartT)
if (IsButtonHeld(EventPlayer(), Button.Jump))
{
	AbortIf(pDownedStartT + 0.5 >= TotalTimeElapsed());
	pDeathCamTarget = null;
	if (pPerkNemesisKiller)
	{
		if (pSpectatedPlayer == EventPlayer())
		{
			pSpectatedPlayer = pPerkNemesisKiller;
		}
		else
		{
			pSpectatedPlayer = EventPlayer();
		}
	}
	else
	{
		# Go to next player
		pSpectatedPlayer = gCombatants[(gCombatants.IndexOf(pSpectatedPlayer) + 1) % CountOf(gCombatants)];
	}
	Wait(0.25, WaitBehavior.IgnoreCondition);
}

rule: "Team 1: Spectated Player does not exist anymore"
Event.OngoingPlayer
Team.Team1
if (!EntityExists(pSpectatedPlayer))
{
	pSpectatedPlayer = EventPlayer();
}

rule: "Team 1: Revive, Check Player in Radius, Unset Is Downed"
Event.OngoingPlayer
Team.Team1
if (pDownedStartT)
if (pDownedStartT + 1 < TotalTimeElapsed())
{
	# Ignores height when reviving
	pRevivers = gCombatants.Filter(
		p => !p.pDownedStartT
		&& !(p.pIsInvisible % 3)
		&& DistanceBetween(
			EventPlayer(),
			Vector(
				p.Position().X,
				EventPlayer().Position().Y,
				p.Position().Z
			)
		) <= 3
		&& AbsoluteValue(EventPlayer().Position().Y - p.Position().Y) <= 3
		&& (
			HeroOf(p) == Hero.Mei
			&& IsUsingAbility1(p)
			|| IsInLineOfSight(EventPlayer(), p, BarrierLOS.NoBarriersBlock)
		)
	);
	if (CountOf(pRevivers))
	{
		pIsReviveSlow = pRevivers.IsTrueForAll(
			p => p.pActiveAbIsCloaked || HasStatus(p, Status.Invincible) || HasStatus(p, Status.PhasedOut)
		);
		pReviveTimer += (gIsHardModeEnabled || gIsApocalyptic ? 0.667 : 1) * (pPerkGoldenHour ? 2 : 1) * (pIsReviveSlow ? 2.5 : 5);
		if (pReviveTimer >= 100)
		{
			SmallMessage(AllPlayers(), " {0} has been revived!".Format([EventPlayer()]));
			pDownedStartT = false;
		}
	}
	else
	{
		pReviveTimer = false;
	}
	Wait(0.2, WaitBehavior.IgnoreCondition);
	LoopIfConditionIsTrue();
}

rule: "Team 1: Teleport if Player died on Jumppad"
Event.OngoingPlayer
Team.Team1
if (pDownedStartT)
if (pDownedStartT + 5 < TotalTimeElapsed())
if (pIsFlying)
{
	gTemp1 = NearestWalkablePosition(EventPlayer().Position() + 5 * DirectionFromAngles(
		RandomInteger(-179, 180),
		false
	));
	nwp_teleport();
}

rule: "Team 1: Player gets up"
Event.OngoingPlayer
Team.Team1
if (!pDownedStartT)
{
	AbortIf(!pIsCombatant);
	EnableMessages(EventPlayer());
	StopCamera(EventPlayer());
	enable_player();
	PlayEffect(AllPlayers(), PlayEffect.BuffImpactSound, Color.White, EventPlayer(), 200);
	SetPlayerHealth(EventPlayer(), 100000);
	pSpectatedPlayer = EventPlayer();
	pRevivers = [];
	pPerkNemesisKiller = null;
	ClearStatus(EventPlayer(), Status.Hacked);
	ClearStatus(EventPlayer(), Status.Invincible);
	enable_player();
	StopScalingPlayer(EventPlayer());
	Wait(2, WaitBehavior.AbortWhenFalse);
	AbortIfConditionIsFalse();
	ClearStatus(EventPlayer(), Status.PhasedOut);
}

rule: "Team 1: Heal after few sec"
Event.OngoingPlayer
Team.Team1
if (pLastDamageTakenT + (pPerkDieHard ? 0.5 : 1) * (gMutDeepWounds ? 5 : 2.5) < TotalTimeElapsed())
if (NormalizedHealth(EventPlayer()) != 1)
if (EventPlayer().Health())
{
	Heal(EventPlayer(), null, EventPlayer().MaxHealth() * 0.333);
	PlayEffect(EventPlayer(), PlayEffect.BuffExplosionSound, Color.White, EventPlayer(), 50);
	while (true)
	{
		Wait(0.2, WaitBehavior.AbortWhenFalse);
		AbortIfConditionIsFalse();
		Heal(EventPlayer(), null, 40);
	}
}

rule: "Team 1: Set / Unset Is Flying"
Event.OngoingPlayer
Team.Team1
if (!IsOnGround(EventPlayer()))
{
	Wait(1.5, WaitBehavior.AbortWhenFalse);
	pIsFlying = true;
	WaitUntil(IsOnGround(EventPlayer()), 99999);
	pIsFlying = false;
}

rule: "Team 1: Calculate Eye Offset"
Event.OngoingPlayer
Team.Team1
if (pIsCombatant)
{
	if (EventPlayer().Hero() == Hero.Mei && EventPlayer().IsUsingAbility1())
	{
		pEyeOffset = 1.2 * Up();
	}
	else if (
		HasStatus(EventPlayer(), Status.KnockedDown)
		|| HasStatus(EventPlayer(), Status.Asleep)
		|| IsCommunicatingAnyEmote(EventPlayer())
	)
	{
		pEyeOffset = EventPlayer().Position() + 0.25 * Up() - EventPlayer().EyePosition();
	}
	else
	{
		pEyeOffset = gAimOffset;
	}
	if (pActiveAbIsSmoked)
	{
		pActiveAbIsSmoked = false;
		pEyeOffset += RandomReal(0.5, 2) * DirectionFromAngles(RandomInteger(-179, 180), RandomInteger(0, 45));
	}
	Wait(1, WaitBehavior.IgnoreCondition);
	LoopIfConditionIsTrue();
}

rule: "Team 1 Button: Hold or double tap Melee, Use active Ability"
Event.OngoingPlayer
Team.Team1
if (EventPlayer().IsButtonHeld(Button.Melee))
{
	WaitUntil(!EventPlayer().IsButtonHeld(Button.Melee), 0.4);
	if (!EventPlayer().IsButtonHeld(Button.Melee))
	{
		WaitUntil(EventPlayer().IsButtonHeld(Button.Melee), 0.3);
		AbortIf(!EventPlayer().IsButtonHeld(Button.Melee));
	}
	AbortIf(
		EventPlayer().IsDead()
		|| pDownedStartT
		|| HasStatus(EventPlayer(), Status.Hacked)
		|| HasStatus(EventPlayer(), Status.Stunned)
		|| !pActiveAbNumber
		|| pInBuyMenu
	);
	PlayEffect(EventPlayer(), PlayEffect.DebuffImpactSound, Color.White, EventPlayer(), 200);
	if (pActiveAbNumber == 1)
	{
		pLastDamageTakenT = false;
		SetStatus(EventPlayer(), null, Status.Invincible, 0.1);
		pDamageDealt += 100;
		pHealingDealtPercent += 100;
		pMoveSpeed += 50;
		for (pActiveAbCooldown = -6; 0; 1)
		{
			Wait(1, WaitBehavior.IgnoreCondition);
		}
		pDamageDealt -= 100;
		pHealingDealtPercent -= 100;
		pMoveSpeed -= 50;
		pActiveAbCooldown = 30;
	}
	else if (pActiveAbNumber == 2)
	{
		pActiveAbIsCloaked = true;
		for (pActiveAbCooldown = -8; 0; 1)
		{
			Wait(1, WaitBehavior.IgnoreCondition);
		}
		pActiveAbIsCloaked = false;
		Damage(PlayersWithinRadius(EventPlayer().EyePosition(), 10, Team.Team2, RadiusLOS.Surfaces), EventPlayer(), 99);
		SetStatus(PlayersWithinRadius(EventPlayer().EyePosition(), 10, Team.Team2, RadiusLOS.Surfaces), EventPlayer(), Status.Frozen, 4);
		PlayEffect(AllPlayers(), PlayEffect.GoodExplosion, Color.Aqua, EventPlayer().EyePosition(), 10);
		PlayEffect(AllPlayers(), PlayEffect.ExplosionSound, Color.White, EventPlayer(), 200);
		pActiveAbCooldown = 20;
	}
	else if (pActiveAbNumber == 3)
	{
		pActiveAbCooldown = -1;
		gTemp1 = PlayersWithinRadius(EventPlayer().EyePosition(), 6, Team.Team2, RadiusLOS.Surfaces);
		Damage(gTemp1, EventPlayer(), 100);
		ApplyImpulse(EventPlayer(), ThrottleOf(EventPlayer()) != Vector(0, 0, 0) ? ThrottleOf(EventPlayer()) : Forward(), 25, Relative.ToPlayer, ContraryMotion.Cancel);
		PlayEffect(AllPlayers(), PlayEffect.BadExplosion, Color.Black, EventPlayer().EyePosition(), 6);
		PlayEffect(AllPlayers(), PlayEffect.ExplosionSound, Color.White, EventPlayer(), 200);
		SetGravity(EventPlayer(), 0);
		SetStatus(EventPlayer(), null, Status.PhasedOut, 0.7);
		Wait(0.6, WaitBehavior.IgnoreCondition);
		SetGravity(EventPlayer(), 100);
		gTemp1 = PlayersWithinRadius(EventPlayer().EyePosition(), 6, Team.Team2, RadiusLOS.Surfaces);
		Damage(gTemp1, EventPlayer(), 100);
		PlayEffect(AllPlayers(), PlayEffect.BadExplosion, Color.Black, EventPlayer().EyePosition(), 6);
		PlayEffect(AllPlayers(), PlayEffect.ExplosionSound, Color.White, EventPlayer(), 200);
		pActiveAbCooldown = 10;
		Wait(1, WaitBehavior.IgnoreCondition);
	}
	else if (pActiveAbNumber == 4)
	{
		pActiveAbIsFrenzied = true;
		SetStatus(EventPlayer(), null, Status.Invincible, 5);
		for (pActiveAbCooldown = -5; 0; 1)
		{
			pLastDamageTakenT = TotalTimeElapsed();
			Wait(1, WaitBehavior.IgnoreCondition);
		}
		pActiveAbIsFrenzied = false;
		pActiveAbCooldown = 30;
	}
	else if (pActiveAbNumber == 5)
	{
		pActiveAbVar = RayCastHitPosition(EventPlayer().EyePosition(), EventPlayer().EyePosition() + 2 * Down(), null, null, false) + 2 * Up();
		for (pActiveAbCooldown = -10; 0; 0.5)
		{
			gCombatants.Filter(
				p => DistanceBetween(p.EyePosition(), Vector(XOf(pActiveAbVar), p.EyePosition().Y, ZOf(pActiveAbVar))) <= 10
				&& AbsoluteValue(p.EyePosition().Y - YOf(pActiveAbVar)) <= 5
			).pActiveAbIsSmoked = true;
			Wait(0.5, WaitBehavior.IgnoreCondition);
		}
		pActiveAbCooldown = 20;
	}
	else if (pActiveAbNumber == 6)
	{
		for (pActiveAbCooldown = -5; 0; 0.25)
		{
			if (NormalizedHealth(EventPlayer()) != 1)
			{
				Heal(EventPlayer(), null, 75);
			}
			if (NormalizedHealth(EventPlayer()) == 1)
			{
				Heal(
					PlayersWithinRadius(EventPlayer(), 15, Team.Team1, RadiusLOS.Off).Filter(
						p => p.pIsCombatant
						&& !p.pDownedStartT
						&& NormalizedHealth(p) != 1
					).Sort(p => NormalizedHealth(p))[0],
					null,
					75
				);
			}
			Wait(0.25, WaitBehavior.IgnoreCondition);
		}
		pActiveAbCooldown = 25;
	}
	else if (pActiveAbNumber == 7)
	{
		pActiveAbVar = RayCastHitPosition(
			EventPlayer().EyePosition(),
			EventPlayer().EyePosition() + 100 * EventPlayer().FacingDirection(),
			AllPlayers(Team.Team2),
			null,
			true
		);
		PlayEffect(AllPlayers(), PlayEffect.GoodExplosion, Color.White, pActiveAbVar, 8);
		PlayEffect(AllPlayers(), PlayEffect.ExplosionSound, Color.White, pActiveAbVar, 200);
		for (pActiveAbCooldown = -6; 0; 1)
		{
			gTemp1 = AllLivingPlayers(Team.Team2).Filter(
				p => !HasStatus(p, Status.PhasedOut)
				&& !HasStatus(p, Status.Stunned)
				&& DistanceBetween(pActiveAbVar, EyePosition(p)) <= 8
			);
			StartDamageOverTime(gTemp1, EventPlayer(), 2, 40);
			for (gIterator = 0; CountOf(gTemp1); 1)
			{
				gTemp1[gIterator].pGmutFortifiedBypassEndT = Max(
					TotalTimeElapsed(),
					gTemp1[gIterator].pGmutFortifiedBypassEndT
				);
				SetStatus(gTemp1[gIterator], EventPlayer(), Status.Stunned, gTemp1[gTemp2].pIsFortified ? 0.5 : 1);
			}
			Wait(2, WaitBehavior.IgnoreCondition);
		}
		pActiveAbCooldown = 35;
	}
	else if (pActiveAbNumber == 8)
	{
		gTemp1 = AllLivingPlayers(Team.Team2).Filter(
			p => !HasStatus(p, Status.PhasedOut)
			&& !p.pIvIsPortal
			&& IsInViewAngle(EventPlayer(), p, 45)
			&& IsInLineOfSight(EventPlayer().EyePosition(), EyePosition(p), BarrierLOS.NoBarriersBlock)
		).Sort(p => DotProduct(EventPlayer().FacingDirection(), DirectionTowards(EventPlayer().EyePosition(), p))).Last;
		if (gTemp1)
		{
			SetStatus(gTemp1, EventPlayer(), Status.Hacked, 5);
			ModifyVariable(pActiveAbVar, Operation.AppendToArray, gTemp1);
			for (gIterator = 4; 1; -1)
			{
				gTemp1 = AllLivingPlayers(Team.Team2).Remove(pActiveAbVar).Filter(
					p => !HasStatus(p, Status.PhasedOut)
					&& !p.pIvIsPortal
					&& IsInLineOfSight(gTemp1, p, BarrierLOS.NoBarriersBlock)
				).Sort(p => DistanceBetween(gTemp1, p))[0];
				if (gTemp1)
				{
					SetStatus(gTemp1, EventPlayer(), Status.Hacked, gIterator);
					ModifyVariable(pActiveAbVar, Operation.AppendToArray, gTemp1);
				}
				else
				{
					break;
				}
			}
			Damage(pActiveAbVar, EventPlayer(), 5);
			pActiveAbCooldown = -0.8;
			Wait(0.8, WaitBehavior.IgnoreCondition);
			pActiveAbVar = [];
			pActiveAbCooldown = 25;
		}
		else
		{
			pActiveAbCooldown = 1;
		}
	}
	for (pActiveAbCooldown = pActiveAbCooldown; 0; -1)
	{
		Wait(1, WaitBehavior.IgnoreCondition);
	}
}

rule: "Team 1 Doomfist: Meteor Strike (Invisibility 2, not detectable)"
Event.OngoingPlayer
Team.Team1
Player.Doomfist
if (IsUsingUltimate(EventPlayer()))
{
	pIsInvisible = 2;
	WaitUntil(!IsUsingUltimate(EventPlayer()), 99999);
	pIsInvisible = false;
}

rule: "Team 1 D.Va: Fill Ultimate Charge when downed"
Event.OngoingPlayer
Team.Team1
Player.Dva
if (pDownedStartT)
if (UltimateChargePercent(EventPlayer()) != 100)
{
	Wait(0.05, WaitBehavior.AbortWhenFalse);
	SetUltimateCharge(EventPlayer(), 100);
}

//> Outdated
rule: "Team 1 Echo: Stealth (Invisibility 1, detectable)"
Event.OngoingPlayer
Team.Team1
Player.Echo
if (HeroBeingDuplicated(EventPlayer()) == Hero.Sombra)
if (IsUsingAbility1(EventPlayer()))
{
	Wait(0.8, WaitBehavior.AbortWhenFalse);
	pIsInvisible = 1;
	WaitUntil(!IsUsingAbility1(EventPlayer()), 99999);
	pIsInvisible = false;
}

rule: "Team 1 Echo: Remove Stealth when Duplicate ends"
Event.OngoingPlayer
Team.Team1
Player.Echo
if (pIsInvisible == 1)
if (!IsDuplicating(EventPlayer()))
{
	pIsInvisible = false;
}

rule: "Team 1 Echo: Cancel Charge on Boss Enemies"
Event.PlayerDealtKnockback
Team.Team1
Player.Echo
if (HeroBeingDuplicated(EventPlayer()) == Hero.Reinhardt)
if (EventAbility() == null)
if (Victim().pIsLivingBoss)
{
	Damage(Victim(), EventPlayer(), 150);
	CancelPrimaryAction(EventPlayer());
	Victim().pGmutFortifiedBypassEndT = Max(TotalTimeElapsed() + 1.2, Victim().pGmutFortifiedBypassEndT);
	SetStatus(Victim(), EventPlayer(), Status.Stunned, 1.2);
}

rule: "Team 1 Echo: Cancel Chain Hook on Boss Enemies"
Event.OnDamageDealt
Team.Team1
Player.Echo
if (HeroBeingDuplicated(EventPlayer()) == Hero.Roadhog)
if (EventAbility() == Button.Ability1)
if (Victim().pIsLivingBoss)
if (IsUsingAbility1(EventPlayer()))
{
	CancelPrimaryAction(EventPlayer());
	MinWait();
	Victim().pGmutFortifiedBypassEndT = Max(TotalTimeElapsed() + 1, Victim().pGmutFortifiedBypassEndT);
	SetStatus(Victim(), EventPlayer(), Status.Stunned, 1);
}

rule: "Team 1 Mercy: Revive Ability (Player)"
Event.OngoingPlayer
Team.Team1
Player.Mercy
if (IsButtonHeld(EventPlayer(), Button.Ability2))
if (!AbilityCooldown(EventPlayer(), Button.Ability2))
if (!pDownedStartT)
if (!HasStatus(EventPlayer(), Status.Hacked))
if (!HasStatus(EventPlayer(), Status.Stunned))
{
	pAbPlayer = PlayersWithinRadius(EventPlayer(), 10, Team.Team1, RadiusLOS.Off).Filter(
		p => p.pIsCombatant
		&& p.pDownedStartT
		&& p.pDownedStartT + 0.1 < TotalTimeElapsed()
		&& IsInViewAngle(EventPlayer(), p, 45)
	).Sort(p => DotProduct(EventPlayer().FacingDirection(), DirectionTowards(EventPlayer().EyePosition(), p))).Last;
	if (pAbPlayer)
	{
		SmallMessage(AllPlayers(), " {0} has been resurrected by {1}!".Format([pAbPlayer, EventPlayer()]));
		pAbPlayer.pDownedStartT = false;
		PlayEffect(AllPlayers(), PlayEffect.GoodPickupEffect, Color.SkyBlue, pAbPlayer, 1);
		gTemp1 = (gIsHardModeEnabled || gIsApocalyptic ? 1.5 : 1) * [30, 33.333, 40][pAbHaste];
		SetAbilityCooldown(EventPlayer(), Button.Ability2, gTemp1);
		# Workaround: Set Cooldown for Controller Players
		SetAbilityCooldown(EventPlayer(), Button.SecondaryFire, gTemp1);
	}
	Wait(0.05, WaitBehavior.IgnoreCondition);
}

//> Outdated
rule: "Team 1 Sombra: Stealth (Invisibility 1, detectable), end after 20 seconds"
Event.OngoingPlayer
Team.Team1
Player.Sombra
if (IsUsingAbility1(EventPlayer()))
{
	Wait(0.8, WaitBehavior.AbortWhenFalse);
	pIsInvisible = 1;
	for (pSombraStealthTimer = 100; 0; -0.48)
	{
		WaitUntil(!IsUsingAbility1(EventPlayer()), 0.096);
		if (!IsUsingAbility1(EventPlayer()))
		{
			break;
		}
	}
	if (IsUsingAbility1(EventPlayer()))
	{
		PressButton(EventPlayer(), Button.Ability1);
	}
	pIsInvisible = false;
}

rule: "Team 1 Reinhardt: Cancel Charge on Boss Enemies"
Event.PlayerDealtKnockback
Team.Team1
Player.Reinhardt
if (EventAbility() == null)
if (Victim().pIsLivingBoss)
{
	Damage(Victim(), EventPlayer(), 250);
	CancelPrimaryAction(EventPlayer());
	Victim().pGmutFortifiedBypassEndT = Max(TotalTimeElapsed() + 1.2, Victim().pGmutFortifiedBypassEndT);
	SetStatus(Victim(), EventPlayer(), Status.Stunned, 1.2);
}

rule: "Team 1 Roadhog: Cancel Chain Hook on Boss Enemies"
Event.OnDamageDealt
Team.Team1
Player.Roadhog
if (EventAbility() == Button.Ability1)
if (Victim().pIsLivingBoss)
if (IsUsingAbility1(EventPlayer()))
{
	CancelPrimaryAction(EventPlayer());
	MinWait();
	Victim().pGmutFortifiedBypassEndT = Max(TotalTimeElapsed() + 1, Victim().pGmutFortifiedBypassEndT);
	SetStatus(Victim(), EventPlayer(), Status.Stunned, 1);
}

rule: "Team 1 Tracer: Start Health Regeneration after Recall"
Event.OngoingPlayer
Team.Team1
Player.Tracer
if (IsUsingAbility2(EventPlayer()))
{
	Wait(0.85, WaitBehavior.IgnoreCondition);
	pLastDamageTakenT = false;
}

rule: "Team 1 Zenyatta: Harmony target is harder to hit"
Event.OnHealingDealt
Team.Team1
Player.Zenyatta
{
	AbortIf(EventAbility() != Button.Ability1);
	Healee().pActiveAbIsSmoked = true;
	Wait(1, WaitBehavior.IgnoreCondition);
}

rule: "Team 1: Smoke Screen"
Event.OngoingPlayer
Team.Team1
if (pSmokedScreen)
if (pDownedStartT == 0)
{
	StartForcingPlayerOutlines(
		AllPlayers(),
		EventPlayer(),
		false,
		Color.White,
		OutlineType.Default
	);
	WaitUntil(EventPlayer().IsDead(), 4);
	StopForcingPlayerOutlines(AllPlayers(), EventPlayer());
	pSmokedScreen = false;
	StartForcingPlayerOutlines(
		AllPlayers(Team.Team2).Filter(p => p.pIsLivingBoss),
		EventPlayer(),
		true,
		Color.Yellow,
		OutlineType.Always
	);
}

rule: "Team 1: Is Shattered, Start Accelerating"
Event.OnDamageTaken
Team.Team1
if (HasStatus(EventPlayer(), Status.Stunned))
if (HeroOf(Attacker()) == Hero.Reinhardt)
if (EventAbility() == Button.Ultimate)
{
	SetStatus(EventPlayer(), Attacker(), Status.Stunned, 5);
	pLastHitByShatterT = TotalTimeElapsed();
	ApplyImpulse(
		EventPlayer(),
		DirectionFromAngles(HorizontalAngleFromDirection(EventDirection()), 30),
		15,
		Relative.ToWorld,
		ContraryMotion.CancelXYZ
	);
	StartAccelerating(
		EventPlayer(),
		DirectionFromAngles(HorizontalAngleFromDirection(EventDirection()), 30),
		IsInAir(EventPlayer())
			? 100
			: (1 - (TotalTimeElapsed() - pLastHitByShatterT)) * 500,
		15,
		Relative.ToWorld,
		AccelerateRev.DirectionRateAndMaxSpeed
	);
	Wait(1, WaitBehavior.IgnoreCondition);
	ClearStatus(EventPlayer(), Status.Stunned);
	StopAccelerating(EventPlayer());
}

rule: "Widowmaker: Widowmaker Ult"
Event.OngoingPlayer
Team.Team1
Player.Widowmaker
if (IsUsingUltimate(EventPlayer()))
{
	AllPlayers(Team.Team2).pSlowedUntil = 9999 + TotalTimeElapsed();
	WaitUntil(!IsUsingUltimate(EventPlayer()), 9999);
	AllPlayers(Team.Team2).pSlowedUntil = TotalTimeElapsed();
}
